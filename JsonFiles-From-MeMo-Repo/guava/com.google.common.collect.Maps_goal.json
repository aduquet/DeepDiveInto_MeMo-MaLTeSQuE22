[
  {
    "signature": "keyFunction()",
    "name": "keyFunction",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Function<java.util.Map$Entry<K, ?>, K>",
      "name": "com.google.common.base.Function<java.util.Map$Entry<K, ?>, K>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "keyFunction()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "valueOrNull(java.util.Map$Entry<?, V> entry)",
    "name": "valueOrNull",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map$Entry",
          "name": "Entry",
          "isArray": false
        },
        "name": "entry",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "valueOrNull(java.util.Map$Entry<?, V> entry)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "containsEntryImpl(java.util.Collection<java.util.Map$Entry<K, V>> c, java.lang.Object o)",
    "name": "containsEntryImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "o"
      }
    ],
    "equivalence": {
      "member": "containsEntryImpl(java.util.Collection<java.util.Map$Entry<K, V>> c, java.lang.Object o)",
      "comment": "Implements Collection.contains safely for forwarding collections of map entries. If o is an instance of Map.Entry, it is wrapped using #unmodifiableEntry to protect against a possible nefarious equals method. Note that c is the backing (delegate) collection, rather than the forwarding collection.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asValueToValueFunction(com.google.common.collect.Maps$EntryTransformer<? super K, V1, V2> transformer, K key)",
    "name": "asValueToValueFunction",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Function<V1, V2>",
      "name": "com.google.common.base.Function<V1, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "equivalence": {
      "member": "asValueToValueFunction(com.google.common.collect.Maps$EntryTransformer<? super K, V1, V2> transformer, K key)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "uniqueIndex(java.lang.Iterable<V> values, com.google.common.base.Function<? super V, K> keyFunction)",
    "name": "uniqueIndex",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableMap<K, V>",
      "name": "com.google.common.collect.ImmutableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "values"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "keyFunction"
      }
    ],
    "equivalence": {
      "member": "uniqueIndex(java.lang.Iterable<V> values, com.google.common.base.Function<? super V, K> keyFunction)",
      "comment": "Returns a map with the given values, indexed by keys derived from those values. In other words, each input value produces an entry in the map whose key is the result of applying keyFunction to that value. These entries appear in the same order as the input values. Example usage:  Color red = new Color(\"red\", 255, 0, 0); ... ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue); Map<String, Color> colorForName = uniqueIndex(allColors, toStringFunction()); assertThat(colorForName).containsEntry(\"red\", red); If your index may associate multiple values with each key, use Multimaps#index(Iterable, Function) Multimaps.index.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "uniqueIndex(java.util.Iterator<V> values, com.google.common.base.Function<? super V, K> keyFunction)",
    "name": "uniqueIndex",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableMap<K, V>",
      "name": "com.google.common.collect.ImmutableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "values"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "keyFunction"
      }
    ],
    "equivalence": {
      "member": "uniqueIndex(java.util.Iterator<V> values, com.google.common.base.Function<? super V, K> keyFunction)",
      "comment": "Returns a map with the given values, indexed by keys derived from those values. In other words, each input value produces an entry in the map whose key is the result of applying keyFunction to that value. These entries appear in the same order as the input values. Example usage:  Color red = new Color(\"red\", 255, 0, 0); ... Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator(); Map<String, Color> colorForName = uniqueIndex(allColors, toStringFunction()); assertThat(colorForName).containsEntry(\"red\", red); If your index may associate multiple values with each key, use Multimaps#index(Iterator, Function) Multimaps.index.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "keyIterator(java.util.Iterator<java.util.Map$Entry<K, V>> entryIterator)",
    "name": "keyIterator",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Iterator<K>",
      "name": "java.util.Iterator<K>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "entryIterator"
      }
    ],
    "equivalence": {
      "member": "keyIterator(java.util.Iterator<java.util.Map$Entry<K, V>> entryIterator)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "valueFunction()",
    "name": "valueFunction",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Function<java.util.Map$Entry<?, V>, V>",
      "name": "com.google.common.base.Function<java.util.Map$Entry<?, V>, V>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "valueFunction()",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "immutableEnumMap(java.util.Map<K, ? extends V> map)",
    "name": "immutableEnumMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableMap<K, V>",
      "name": "com.google.common.collect.ImmutableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "immutableEnumMap(java.util.Map<K, ? extends V> map)",
      "comment": "Returns an immutable map instance containing the given entries. Internally, the returned map will be backed by an EnumMap. The iteration order of the returned map follows the enum's iteration order, not the order in which the elements appear in the given map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asEntryToValueFunction(com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
    "name": "asEntryToValueFunction",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Function<java.util.Map$Entry<K, V1>, V2>",
      "name": "com.google.common.base.Function<java.util.Map$Entry<K, V1>, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      }
    ],
    "equivalence": {
      "member": "asEntryToValueFunction(com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
      "comment": "Views an entry transformer as a function from Entry to values.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asConverter(com.google.common.collect.BiMap<A, B> bimap)",
    "name": "asConverter",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Converter<A, B>",
      "name": "com.google.common.base.Converter<A, B>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.BiMap",
          "name": "BiMap",
          "isArray": false
        },
        "name": "bimap"
      }
    ],
    "equivalence": {
      "member": "asConverter(com.google.common.collect.BiMap<A, B> bimap)",
      "comment": "Returns a Converter that converts values using BiMap#get bimap.get(), and whose inverse view converts values using BiMap#inverse bimap.inverse().get(). To use a plain Map as a Function, see com.google.common.base.Functions#forMap(Map) or com.google.common.base.Functions#forMap(Map, Object).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "difference(java.util.Map<? extends K, ? extends V> left, java.util.Map<? extends K, ? extends V> right)",
    "name": "difference",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.MapDifference<K, V>",
      "name": "com.google.common.collect.MapDifference<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "left"
      },
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "right"
      }
    ],
    "equivalence": {
      "member": "difference(java.util.Map<? extends K, ? extends V> left, java.util.Map<? extends K, ? extends V> right)",
      "comment": "Computes the difference between two maps. This difference is an immutable snapshot of the state of the maps at the time this method is called. It will never change, even if the maps change at a later time. Since this method uses HashMap instances internally, the keys of the supplied maps must be well-behaved with respect to Object#equals and Object#hashCode. Note:If you only need to know whether two maps have the same mappings, call left.equals(right) instead of this method.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "difference(java.util.SortedMap<K, ? extends V> left, java.util.Map<? extends K, ? extends V> right)",
    "name": "difference",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.SortedMapDifference<K, V>",
      "name": "com.google.common.collect.SortedMapDifference<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "left"
      },
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "right"
      }
    ],
    "equivalence": {
      "member": "difference(java.util.SortedMap<K, ? extends V> left, java.util.Map<? extends K, ? extends V> right)",
      "comment": "Computes the difference between two sorted maps, using the comparator of the left map, or Ordering.natural() if the left map uses the natural ordering of its elements. This difference is an immutable snapshot of the state of the maps at the time this method is called. It will never change, even if the maps change at a later time. Since this method uses TreeMap instances internally, the keys of the right map must all compare as distinct according to the comparator of the left map. Note:If you only need to know whether two sorted maps have the same mappings, call left.equals(right) instead of this method.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asMap(java.util.Set<K> set, com.google.common.base.Function<? super K, V> function)",
    "name": "asMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map<K, V>",
      "name": "java.util.Map<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "asMap(java.util.Set<K> set, com.google.common.base.Function<? super K, V> function)",
      "comment": "Returns a live Map view whose keys are the contents of set and whose values are computed on demand using function. To get an immutable copy instead, use #toMap(Iterable, Function). Specifically, for each k in the backing set, the returned map has an entry mapping k to function.apply(k). The keySet, values, and entrySet views of the returned map iterate in the same order as the backing set. Modifications to the backing set are read through to the returned map. The returned map supports removal operations if the backing set does. Removal operations write through to the backing set. The returned map does not support put operations. Warning: If the function rejects null, caution is required to make sure the set does not contain null, because the view cannot stop null from being added to the set. Warning: This method assumes that for any instance k of key type K, k.equals(k2) implies that k2 is also of type K. Using a key type for which this may not hold, such as ArrayList, may risk a ClassCastException when calling methods on the resulting map view.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asMap(java.util.SortedSet<K> set, com.google.common.base.Function<? super K, V> function)",
    "name": "asMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V>",
      "name": "java.util.SortedMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedSet",
          "name": "SortedSet",
          "isArray": false
        },
        "name": "set"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "asMap(java.util.SortedSet<K> set, com.google.common.base.Function<? super K, V> function)",
      "comment": "Returns a view of the sorted set as a map, mapping keys from the set according to the specified function. Specifically, for each k in the backing set, the returned map has an entry mapping k to function.apply(k). The keySet, values, and entrySet views of the returned map iterate in the same order as the backing set. Modifications to the backing set are read through to the returned map. The returned map supports removal operations if the backing set does. Removal operations write through to the backing set. The returned map does not support put operations. Warning: If the function rejects null, caution is required to make sure the set does not contain null, because the view cannot stop null from being added to the set. Warning: This method assumes that for any instance k of key type K, k.equals(k2) implies that k2 is also of type K. Using a key type for which this may not hold, such as ArrayList, may risk a ClassCastException when calling methods on the resulting map view.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asMap(java.util.NavigableSet<K> set, com.google.common.base.Function<? super K, V> function)",
    "name": "asMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V>",
      "name": "java.util.NavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableSet",
          "name": "NavigableSet",
          "isArray": false
        },
        "name": "set"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "asMap(java.util.NavigableSet<K> set, com.google.common.base.Function<? super K, V> function)",
      "comment": "Returns a view of the navigable set as a map, mapping keys from the set according to the specified function. Specifically, for each k in the backing set, the returned map has an entry mapping k to function.apply(k). The keySet, values, and entrySet views of the returned map iterate in the same order as the backing set. Modifications to the backing set are read through to the returned map. The returned map supports removal operations if the backing set does. Removal operations write through to the backing set. The returned map does not support put operations. Warning: If the function rejects null, caution is required to make sure the set does not contain null, because the view cannot stop null from being added to the set. Warning: This method assumes that for any instance k of key type K, k.equals(k2) implies that k2 is also of type K. Using a key type for which this may not hold, such as ArrayList, may risk a ClassCastException when calling methods on the resulting map view.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newTreeMap(java.util.Comparator<C> comparator)",
    "name": "newTreeMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.TreeMap<K, V>",
      "name": "java.util.TreeMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "comparator",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "newTreeMap(java.util.Comparator<C> comparator)",
      "comment": "Creates a mutable, empty TreeMap instance using the given comparator. Note: if mutability is not required, use ImmutableSortedMap.orderedBy(comparator).build() instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newEnumMap(java.util.Map<K, ? extends V> map)",
    "name": "newEnumMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.EnumMap<K, V>",
      "name": "java.util.EnumMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "newEnumMap(java.util.Map<K, ? extends V> map)",
      "comment": "Creates an EnumMap with the same mappings as the specified map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "unmodifiableEntryIterator(java.util.Iterator<java.util.Map$Entry<K, V>> entryIterator)",
    "name": "unmodifiableEntryIterator",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.UnmodifiableIterator<java.util.Map$Entry<K, V>>",
      "name": "com.google.common.collect.UnmodifiableIterator<java.util.Map$Entry<K, V>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "entryIterator"
      }
    ],
    "equivalence": {
      "member": "unmodifiableEntryIterator(java.util.Iterator<java.util.Map$Entry<K, V>> entryIterator)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "synchronizedBiMap(com.google.common.collect.BiMap<K, V> bimap)",
    "name": "synchronizedBiMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.BiMap<K, V>",
      "name": "com.google.common.collect.BiMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.BiMap",
          "name": "BiMap",
          "isArray": false
        },
        "name": "bimap"
      }
    ],
    "equivalence": {
      "member": "synchronizedBiMap(com.google.common.collect.BiMap<K, V> bimap)",
      "comment": "Returns a synchronized (thread-safe) bimap backed by the specified bimap. In order to guarantee serial access, it is critical that all access to the backing bimap is accomplished through the returned bimap. It is imperative that the user manually synchronize on the returned map when accessing any of its collection views:  BiMap<Long, String> map = Maps.synchronizedBiMap( HashBiMap.<Long, String>create()); ... Set<Long> set = map.keySet(); // Needn't be in synchronized block ... synchronized (map) { // Synchronizing on map, not set! Iterator<Long> it = set.iterator(); // Must be in synchronized block while (it.hasNext()) { foo(it.next());  }} Failure to follow this advice may result in non-deterministic behavior. The returned bimap will be serializable if the specified bimap is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "safeGet(java.util.Map<?, V> map, java.lang.Object key)",
    "name": "safeGet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "safeGet(java.util.Map<?, V> map, java.lang.Object key)",
      "comment": "Delegates to Map#get. Returns null on ClassCastException and NullPointerException.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toStringImpl(java.util.Map<?, ?> map)",
    "name": "toStringImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "toStringImpl(java.util.Map<?, ?> map)",
      "comment": "An implementation of Map#toString.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newTreeMap()",
    "name": "newTreeMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.TreeMap<K, V>",
      "name": "java.util.TreeMap<K, V>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newTreeMap()",
      "comment": "Creates a mutable, empty TreeMap instance using the natural ordering of its elements. Note: if mutability is not required, use ImmutableSortedMap#of() instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "unmodifiableEntrySet(java.util.Set<java.util.Map$Entry<K, V>> entrySet)",
    "name": "unmodifiableEntrySet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<java.util.Map$Entry<K, V>>",
      "name": "java.util.Set<java.util.Map$Entry<K, V>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "entrySet"
      }
    ],
    "equivalence": {
      "member": "unmodifiableEntrySet(java.util.Set<java.util.Map$Entry<K, V>> entrySet)",
      "comment": "Returns an unmodifiable view of the specified set of entries. The Entry#setValue operation throws an UnsupportedOperationException, as do any operations that would modify the returned set.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformEntry(com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer, java.util.Map$Entry<K, V1> entry)",
    "name": "transformEntry",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map$Entry<K, V2>",
      "name": "java.util.Map$Entry<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      },
      {
        "type": {
          "qualifiedName": "java.util.Map$Entry",
          "name": "Entry",
          "isArray": false
        },
        "name": "entry"
      }
    ],
    "equivalence": {
      "member": "transformEntry(com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer, java.util.Map$Entry<K, V1> entry)",
      "comment": "Returns a view of an entry transformed by the specified transformer.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterEntries(java.util.Map<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
    "name": "filterEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map<K, V>",
      "name": "java.util.Map<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "entryPredicate"
      }
    ],
    "equivalence": {
      "member": "filterEntries(java.util.Map<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
      "comment": "Returns a map containing the mappings in unfiltered that satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's put() and putAll() methods throw an IllegalArgumentException. Similarly, the map's entries have a Entry#setValue method that throws an IllegalArgumentException when the existing key and the provided value don't satisfy the predicate. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: entryPredicate must be consistent with equals, as documented at Predicate#apply.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterEntries(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
    "name": "filterEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V>",
      "name": "java.util.SortedMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "entryPredicate"
      }
    ],
    "equivalence": {
      "member": "filterEntries(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
      "comment": "Returns a sorted map containing the mappings in unfiltered that satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's put() and putAll() methods throw an IllegalArgumentException. Similarly, the map's entries have a Entry#setValue method that throws an IllegalArgumentException when the existing key and the provided value don't satisfy the predicate. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: entryPredicate must be consistent with equals, as documented at Predicate#apply.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterEntries(java.util.NavigableMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
    "name": "filterEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V>",
      "name": "java.util.NavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableMap",
          "name": "NavigableMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "entryPredicate"
      }
    ],
    "equivalence": {
      "member": "filterEntries(java.util.NavigableMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
      "comment": "Returns a sorted map containing the mappings in unfiltered that satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's put() and putAll() methods throw an IllegalArgumentException. Similarly, the map's entries have a Entry#setValue method that throws an IllegalArgumentException when the existing key and the provided value don't satisfy the predicate. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: entryPredicate must be consistent with equals, as documented at Predicate#apply.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterEntries(com.google.common.collect.BiMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
    "name": "filterEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.BiMap<K, V>",
      "name": "com.google.common.collect.BiMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.BiMap",
          "name": "BiMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "entryPredicate"
      }
    ],
    "equivalence": {
      "member": "filterEntries(com.google.common.collect.BiMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
      "comment": "Returns a bimap containing the mappings in unfiltered that satisfy a predicate. The returned bimap is a live view of unfiltered; changes to one affect the other. The resulting bimap's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the bimap and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's put(), forcePut() and putAll() methods throw an IllegalArgumentException. Similarly, the map's entries have an Entry#setValue method that throws an IllegalArgumentException when the existing key and the provided value don't satisfy the predicate. When methods such as removeAll() and clear() are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap. The returned bimap isn't threadsafe or serializable, even if unfiltered is. Many of the filtered bimap's methods, such as size(), iterate across every key/value mapping in the underlying bimap and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered bimap and use the copy. Warning: entryPredicate must be consistent with equals , as documented at Predicate#apply.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "keyPredicateOnEntries(com.google.common.base.Predicate<? super K> keyPredicate)",
    "name": "keyPredicateOnEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Predicate<java.util.Map$Entry<K, ?>>",
      "name": "com.google.common.base.Predicate<java.util.Map$Entry<K, ?>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "keyPredicate"
      }
    ],
    "equivalence": {
      "member": "keyPredicateOnEntries(com.google.common.base.Predicate<? super K> keyPredicate)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "unmodifiableBiMap(com.google.common.collect.BiMap<? extends K, ? extends V> bimap)",
    "name": "unmodifiableBiMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.BiMap<K, V>",
      "name": "com.google.common.collect.BiMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.BiMap",
          "name": "BiMap",
          "isArray": false
        },
        "name": "bimap"
      }
    ],
    "equivalence": {
      "member": "unmodifiableBiMap(com.google.common.collect.BiMap<? extends K, ? extends V> bimap)",
      "comment": "Returns an unmodifiable view of the specified bimap. This method allows modules to provide users with \"read-only\" access to internal bimaps. Query operations on the returned bimap \"read through\" to the specified bimap, and attempts to modify the returned map, whether direct or via its collection views, result in an UnsupportedOperationException. The returned bimap will be serializable if the specified bimap is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "indexMap(java.util.Collection<E> list)",
    "name": "indexMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableMap<E, java.lang.Integer>",
      "name": "com.google.common.collect.ImmutableMap<E, java.lang.Integer>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "list"
      }
    ],
    "equivalence": {
      "member": "indexMap(java.util.Collection<E> list)",
      "comment": "Returns a map from the ith element of list to i.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedHashMap()",
    "name": "newLinkedHashMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedHashMap<K, V>",
      "name": "java.util.LinkedHashMap<K, V>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newLinkedHashMap()",
      "comment": "Creates a mutable, empty, insertion-ordered LinkedHashMap instance. Note: if mutability is not required, use ImmutableMap#of() instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "fromProperties(java.util.Properties properties)",
    "name": "fromProperties",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableMap<java.lang.String, java.lang.String>",
      "name": "com.google.common.collect.ImmutableMap<java.lang.String, java.lang.String>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Properties",
          "name": "Properties",
          "isArray": false
        },
        "name": "properties"
      }
    ],
    "equivalence": {
      "member": "fromProperties(java.util.Properties properties)",
      "comment": "Creates an ImmutableMap<String, String> from a Properties instance. Properties normally derive from Map<Object, Object>, but they typically contain strings, which is awkward. This method lets you get a plain-old-Map out of a Properties.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedHashMapWithExpectedSize(int expectedSize)",
    "name": "newLinkedHashMapWithExpectedSize",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedHashMap<K, V>",
      "name": "java.util.LinkedHashMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "expectedSize"
      }
    ],
    "equivalence": {
      "member": "newLinkedHashMapWithExpectedSize(int expectedSize)",
      "comment": "Creates a LinkedHashMap instance, with a high enough \"initial capacity\" that it should hold expectedSize elements without growth. This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method isn't inadvertently oversizing the returned map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "difference(java.util.Map<? extends K, ? extends V> left, java.util.Map<? extends K, ? extends V> right, com.google.common.base.Equivalence<? super V> valueEquivalence)",
    "name": "difference",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.MapDifference<K, V>",
      "name": "com.google.common.collect.MapDifference<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "left"
      },
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "right"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Equivalence",
          "name": "Equivalence",
          "isArray": false
        },
        "name": "valueEquivalence"
      }
    ],
    "equivalence": {
      "member": "difference(java.util.Map<? extends K, ? extends V> left, java.util.Map<? extends K, ? extends V> right, com.google.common.base.Equivalence<? super V> valueEquivalence)",
      "comment": "Computes the difference between two maps. This difference is an immutable snapshot of the state of the maps at the time this method is called. It will never change, even if the maps change at a later time. Values are compared using a provided equivalence, in the case of equality, the value on the 'left' is returned in the difference. Since this method uses HashMap instances internally, the keys of the supplied maps must be well-behaved with respect to Object#equals and Object#hashCode.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newTreeMap(java.util.SortedMap<K, ? extends V> map)",
    "name": "newTreeMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.TreeMap<K, V>",
      "name": "java.util.TreeMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "newTreeMap(java.util.SortedMap<K, ? extends V> map)",
      "comment": "Creates a mutable TreeMap instance with the same mappings as the specified map and using the same ordering as the specified map. Note: if mutability is not required, use ImmutableSortedMap#copyOfSorted(SortedMap) instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equalsImpl(java.util.Map<?, ?> map, java.lang.Object object)",
    "name": "equalsImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "object"
      }
    ],
    "equivalence": {
      "member": "equalsImpl(java.util.Map<?, ?> map, java.lang.Object object)",
      "comment": "An implementation of Map#equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "valuePredicateOnEntries(com.google.common.base.Predicate<? super V> valuePredicate)",
    "name": "valuePredicateOnEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Predicate<java.util.Map$Entry<?, V>>",
      "name": "com.google.common.base.Predicate<java.util.Map$Entry<?, V>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "valuePredicate"
      }
    ],
    "equivalence": {
      "member": "valuePredicateOnEntries(com.google.common.base.Predicate<? super V> valuePredicate)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformEntries(java.util.Map<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
    "name": "transformEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map<K, V2>",
      "name": "java.util.Map<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "fromMap"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      }
    ],
    "equivalence": {
      "member": "transformEntries(java.util.Map<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
      "comment": "Returns a view of a map whose values are derived from the original map's entries. In contrast to #transformValues, this method's entry-transformation logic may depend on the key as well as the value. All other properties of the transformed map, such as iteration order, are left intact. For example, the code:  Map<String, Boolean> options = ImmutableMap.of(\"verbose\", true, \"sort\", false); EntryTransformer<String, Boolean, String> flagPrefixer = new EntryTransformer<String, Boolean, String>() { public String transformEntry(String key, Boolean value) { return value ? key : \"no\" + key;  }; Map<String, String> transformed = Maps.transformEntries(options, flagPrefixer); System.out.println(transformed);} ... prints {verbose=verbose, sort=nosort}. Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map. It's acceptable for the underlying map to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed map might contain null values if the transformer sometimes gives a null result. The returned map is not thread-safe or serializable, even if the underlying map is. The transformer is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the transformer will be applied many times for bulk operations like Map#containsValue and Object#toString. For this to perform well, transformer should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing. Warning: This method assumes that for any instance k of EntryTransformer key type K, k.equals(k2) implies that k2 is also of type K. Using an EntryTransformer key type for which this may not hold, such as ArrayList, may risk a ClassCastException when calling methods on the transformed map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformEntries(java.util.SortedMap<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
    "name": "transformEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V2>",
      "name": "java.util.SortedMap<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "fromMap"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      }
    ],
    "equivalence": {
      "member": "transformEntries(java.util.SortedMap<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
      "comment": "Returns a view of a sorted map whose values are derived from the original sorted map's entries. In contrast to #transformValues, this method's entry-transformation logic may depend on the key as well as the value. All other properties of the transformed map, such as iteration order, are left intact. For example, the code:  Map<String, Boolean> options = ImmutableSortedMap.of(\"verbose\", true, \"sort\", false); EntryTransformer<String, Boolean, String> flagPrefixer = new EntryTransformer<String, Boolean, String>() { public String transformEntry(String key, Boolean value) { return value ? key : \"yes\" + key;  }; SortedMap<String, String> transformed = Maps.transformEntries(options, flagPrefixer); System.out.println(transformed);} ... prints {sort=yessort, verbose=verbose}. Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map. It's acceptable for the underlying map to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed map might contain null values if the transformer sometimes gives a null result. The returned map is not thread-safe or serializable, even if the underlying map is. The transformer is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the transformer will be applied many times for bulk operations like Map#containsValue and Object#toString. For this to perform well, transformer should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing. Warning: This method assumes that for any instance k of EntryTransformer key type K, k.equals(k2) implies that k2 is also of type K. Using an EntryTransformer key type for which this may not hold, such as ArrayList, may risk a ClassCastException when calling methods on the transformed map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformEntries(java.util.NavigableMap<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
    "name": "transformEntries",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V2>",
      "name": "java.util.NavigableMap<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableMap",
          "name": "NavigableMap",
          "isArray": false
        },
        "name": "fromMap"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      }
    ],
    "equivalence": {
      "member": "transformEntries(java.util.NavigableMap<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
      "comment": "Returns a view of a navigable map whose values are derived from the original navigable map's entries. In contrast to #transformValues, this method's entry-transformation logic may depend on the key as well as the value. All other properties of the transformed map, such as iteration order, are left intact. For example, the code:  NavigableMap<String, Boolean> options = Maps.newTreeMap(); options.put(\"verbose\", false); options.put(\"sort\", true); EntryTransformer<String, Boolean, String> flagPrefixer = new EntryTransformer<String, Boolean, String>() { public String transformEntry(String key, Boolean value) { return value ? key : (\"yes\" + key);  }; NavigableMap<String, String> transformed = LabsMaps.transformNavigableEntries(options, flagPrefixer); System.out.println(transformed);} ... prints {sort=yessort, verbose=verbose}. Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map. It's acceptable for the underlying map to contain null keys and null values provided that the transformer is capable of accepting null inputs. The transformed map might contain null values if the transformer sometimes gives a null result. The returned map is not thread-safe or serializable, even if the underlying map is. The transformer is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the transformer will be applied many times for bulk operations like Map#containsValue and Object#toString. For this to perform well, transformer should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing. Warning: This method assumes that for any instance k of EntryTransformer key type K, k.equals(k2) implies that k2 is also of type K. Using an EntryTransformer key type for which this may not hold, such as ArrayList, may risk a ClassCastException when calling methods on the transformed map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "unmodifiableEntry(java.util.Map$Entry<? extends K, ? extends V> entry)",
    "name": "unmodifiableEntry",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map$Entry<K, V>",
      "name": "java.util.Map$Entry<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map$Entry",
          "name": "Entry",
          "isArray": false
        },
        "name": "entry"
      }
    ],
    "equivalence": {
      "member": "unmodifiableEntry(java.util.Map$Entry<? extends K, ? extends V> entry)",
      "comment": "Returns an unmodifiable view of the specified map entry. The Entry#setValue operation throws an UnsupportedOperationException. This also has the side-effect of redefining equals to comply with the Entry contract, to avoid a possible nefarious implementation of equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterValues(java.util.Map<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
    "name": "filterValues",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map<K, V>",
      "name": "java.util.Map<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "valuePredicate"
      }
    ],
    "equivalence": {
      "member": "filterValues(java.util.Map<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
      "comment": "Returns a map containing the mappings in unfiltered whose values satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's put(), putAll(), and Entry#setValue methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: valuePredicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterValues(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
    "name": "filterValues",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V>",
      "name": "java.util.SortedMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "valuePredicate"
      }
    ],
    "equivalence": {
      "member": "filterValues(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
      "comment": "Returns a sorted map containing the mappings in unfiltered whose values satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's put(), putAll(), and Entry#setValue methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: valuePredicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterValues(java.util.NavigableMap<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
    "name": "filterValues",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V>",
      "name": "java.util.NavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableMap",
          "name": "NavigableMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "valuePredicate"
      }
    ],
    "equivalence": {
      "member": "filterValues(java.util.NavigableMap<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
      "comment": "Returns a navigable map containing the mappings in unfiltered whose values satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's put(), putAll(), and Entry#setValue methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: valuePredicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterValues(com.google.common.collect.BiMap<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
    "name": "filterValues",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.BiMap<K, V>",
      "name": "com.google.common.collect.BiMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.BiMap",
          "name": "BiMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "valuePredicate"
      }
    ],
    "equivalence": {
      "member": "filterValues(com.google.common.collect.BiMap<K, V> unfiltered, com.google.common.base.Predicate<? super V> valuePredicate)",
      "comment": "Returns a bimap containing the mappings in unfiltered whose values satisfy a predicate. The returned bimap is a live view of unfiltered; changes to one affect the other. The resulting bimap's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's put(), forcePut() and putAll() methods throw an IllegalArgumentException. Similarly, the map's entries have a Entry#setValue method that throws an IllegalArgumentException when the provided value doesn't satisfy the predicate. When methods such as removeAll() and clear() are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap. The returned bimap isn't threadsafe or serializable, even if unfiltered is. Many of the filtered bimap's methods, such as size(), iterate across every value in the underlying bimap and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered bimap and use the copy. Warning: entryPredicate must be consistent with equals , as documented at Predicate#apply.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "unmodifiableNavigableMap(java.util.NavigableMap<K, V> map)",
    "name": "unmodifiableNavigableMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V>",
      "name": "java.util.NavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableMap",
          "name": "NavigableMap",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "unmodifiableNavigableMap(java.util.NavigableMap<K, V> map)",
      "comment": "Returns an unmodifiable view of the specified navigable map. Query operations on the returned map read through to the specified map, and attempts to modify the returned map, whether direct or via its views, result in an UnsupportedOperationException. The returned navigable map will be serializable if the specified navigable map is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "safeRemove(java.util.Map<?, V> map, java.lang.Object key)",
    "name": "safeRemove",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "V",
      "name": "V",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "equivalence": {
      "member": "safeRemove(java.util.Map<?, V> map, java.lang.Object key)",
      "comment": "Delegates to Map#remove. Returns null on ClassCastException and NullPointerException.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashMap()",
    "name": "newHashMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.HashMap<K, V>",
      "name": "java.util.HashMap<K, V>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newHashMap()",
      "comment": "Creates a mutable, empty HashMap instance. Note: if mutability is not required, use ImmutableMap#of() instead. Note: if K is an enum type, use #newEnumMap instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterKeys(java.util.Map<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
    "name": "filterKeys",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map<K, V>",
      "name": "java.util.Map<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "keyPredicate"
      }
    ],
    "equivalence": {
      "member": "filterKeys(java.util.Map<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
      "comment": "Returns a map containing the mappings in unfiltered whose keys satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's put() and putAll() methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: keyPredicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterKeys(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
    "name": "filterKeys",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V>",
      "name": "java.util.SortedMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "keyPredicate"
      }
    ],
    "equivalence": {
      "member": "filterKeys(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
      "comment": "Returns a sorted map containing the mappings in unfiltered whose keys satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's put() and putAll() methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: keyPredicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterKeys(java.util.NavigableMap<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
    "name": "filterKeys",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V>",
      "name": "java.util.NavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableMap",
          "name": "NavigableMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "keyPredicate"
      }
    ],
    "equivalence": {
      "member": "filterKeys(java.util.NavigableMap<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
      "comment": "Returns a navigable map containing the mappings in unfiltered whose keys satisfy a predicate. The returned map is a live view of unfiltered; changes to one affect the other. The resulting map's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's put() and putAll() methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map. The returned map isn't threadsafe or serializable, even if unfiltered is. Many of the filtered map's methods, such as size(), iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered map and use the copy. Warning: keyPredicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterKeys(com.google.common.collect.BiMap<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
    "name": "filterKeys",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.BiMap<K, V>",
      "name": "com.google.common.collect.BiMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.BiMap",
          "name": "BiMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "keyPredicate"
      }
    ],
    "equivalence": {
      "member": "filterKeys(com.google.common.collect.BiMap<K, V> unfiltered, com.google.common.base.Predicate<? super K> keyPredicate)",
      "comment": "Returns a bimap containing the mappings in unfiltered whose keys satisfy a predicate. The returned bimap is a live view of unfiltered; changes to one affect the other. The resulting bimap's keySet(), entrySet(), and values() views have iterators that don't support remove(), but all other methods are supported by the bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's put(), forcePut() and putAll() methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap. The returned bimap isn't threadsafe or serializable, even if unfiltered is. Many of the filtered bimap's methods, such as size(), iterate across every key in the underlying bimap and determine which satisfy the filter. When a live view is not needed, it may be faster to copy the filtered bimap and use the copy. Warning: entryPredicate must be consistent with equals , as documented at Predicate#apply.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashMap(java.util.Map<? extends K, ? extends V> map)",
    "name": "newHashMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.HashMap<K, V>",
      "name": "java.util.HashMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "newHashMap(java.util.Map<? extends K, ? extends V> map)",
      "comment": "Creates a mutable HashMap instance with the same mappings as the specified map. Note: if mutability is not required, use ImmutableMap#copyOf(Map) instead. Note: if K is an Enum type, use #newEnumMap instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "removeEntryImpl(java.util.Collection<java.util.Map$Entry<K, V>> c, java.lang.Object o)",
    "name": "removeEntryImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "c"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "o"
      }
    ],
    "equivalence": {
      "member": "removeEntryImpl(java.util.Collection<java.util.Map$Entry<K, V>> c, java.lang.Object o)",
      "comment": "Implements Collection.remove safely for forwarding collections of map entries. If o is an instance of Map.Entry, it is wrapped using #unmodifiableEntry to protect against a possible nefarious equals method. Note that c is backing (delegate) collection, rather than the forwarding collection.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "valueIterator(java.util.Iterator<java.util.Map$Entry<K, V>> entryIterator)",
    "name": "valueIterator",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Iterator<V>",
      "name": "java.util.Iterator<V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "entryIterator"
      }
    ],
    "equivalence": {
      "member": "valueIterator(java.util.Iterator<java.util.Map$Entry<K, V>> entryIterator)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformValues(java.util.Map<K, V1> fromMap, com.google.common.base.Function<? super V1, V2> function)",
    "name": "transformValues",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map<K, V2>",
      "name": "java.util.Map<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "fromMap"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "transformValues(java.util.Map<K, V1> fromMap, com.google.common.base.Function<? super V1, V2> function)",
      "comment": "Returns a view of a map where each value is transformed by a function. All other properties of the map, such as iteration order, are left intact. For example, the code:  Map<String, Integer> map = ImmutableMap.of(\"a\", 4, \"b\", 9); Function<Integer, Double> sqrt = new Function<Integer, Double>() { public Double apply(Integer in) { return Math.sqrt((int) in);  }; Map<String, Double> transformed = Maps.transformValues(map, sqrt); System.out.println(transformed);} ... prints {a=2.0, b=3.0}. Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map. It's acceptable for the underlying map to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed map might contain null values, if the function sometimes gives a null result. The returned map is not thread-safe or serializable, even if the underlying map is. The function is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the function will be applied many times for bulk operations like Map#containsValue and Map.toString(). For this to perform well, function should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformValues(java.util.SortedMap<K, V1> fromMap, com.google.common.base.Function<? super V1, V2> function)",
    "name": "transformValues",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V2>",
      "name": "java.util.SortedMap<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "fromMap"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "transformValues(java.util.SortedMap<K, V1> fromMap, com.google.common.base.Function<? super V1, V2> function)",
      "comment": "Returns a view of a sorted map where each value is transformed by a function. All other properties of the map, such as iteration order, are left intact. For example, the code:  SortedMap<String, Integer> map = ImmutableSortedMap.of(\"a\", 4, \"b\", 9); Function<Integer, Double> sqrt = new Function<Integer, Double>() { public Double apply(Integer in) { return Math.sqrt((int) in);  }; SortedMap<String, Double> transformed = Maps.transformValues(map, sqrt); System.out.println(transformed);} ... prints {a=2.0, b=3.0}. Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map. It's acceptable for the underlying map to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed map might contain null values, if the function sometimes gives a null result. The returned map is not thread-safe or serializable, even if the underlying map is. The function is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the function will be applied many times for bulk operations like Map#containsValue and Map.toString(). For this to perform well, function should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformValues(java.util.NavigableMap<K, V1> fromMap, com.google.common.base.Function<? super V1, V2> function)",
    "name": "transformValues",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V2>",
      "name": "java.util.NavigableMap<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableMap",
          "name": "NavigableMap",
          "isArray": false
        },
        "name": "fromMap"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "transformValues(java.util.NavigableMap<K, V1> fromMap, com.google.common.base.Function<? super V1, V2> function)",
      "comment": "Returns a view of a navigable map where each value is transformed by a function. All other properties of the map, such as iteration order, are left intact. For example, the code:  NavigableMap<String, Integer> map = Maps.newTreeMap(); map.put(\"a\", 4); map.put(\"b\", 9); Function<Integer, Double> sqrt = new Function<Integer, Double>() { public Double apply(Integer in) { return Math.sqrt((int) in);  }; NavigableMap<String, Double> transformed = Maps.transformNavigableValues(map, sqrt); System.out.println(transformed);} ... prints {a=2.0, b=3.0}. Changes in the underlying map are reflected in this view. Conversely, this view supports removal operations, and these are reflected in the underlying map. It's acceptable for the underlying map to contain null keys, and even null values provided that the function is capable of accepting null input. The transformed map might contain null values, if the function sometimes gives a null result. The returned map is not thread-safe or serializable, even if the underlying map is. The function is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the function will be applied many times for bulk operations like Map#containsValue and Map.toString(). For this to perform well, function should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "capacity(int expectedSize)",
    "name": "capacity",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "expectedSize"
      }
    ],
    "equivalence": {
      "member": "capacity(int expectedSize)",
      "comment": "Returns a capacity that is sufficient to keep the map from being resized as long as it grows no larger than expectedSize and the load factor is >= its default (0.75).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asMapSortedIgnoreNavigable(java.util.SortedSet<K> set, com.google.common.base.Function<? super K, V> function)",
    "name": "asMapSortedIgnoreNavigable",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V>",
      "name": "java.util.SortedMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedSet",
          "name": "SortedSet",
          "isArray": false
        },
        "name": "set"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "asMapSortedIgnoreNavigable(java.util.SortedSet<K> set, com.google.common.base.Function<? super K, V> function)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newEnumMap(java.lang.Class<K> type)",
    "name": "newEnumMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.EnumMap<K, V>",
      "name": "java.util.EnumMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Class",
          "name": "Class",
          "isArray": false
        },
        "name": "type"
      }
    ],
    "equivalence": {
      "member": "newEnumMap(java.lang.Class<K> type)",
      "comment": "Creates an EnumMap instance.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toMap(java.lang.Iterable<K> keys, com.google.common.base.Function<? super K, V> valueFunction)",
    "name": "toMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableMap<K, V>",
      "name": "com.google.common.collect.ImmutableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "keys"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "valueFunction"
      }
    ],
    "equivalence": {
      "member": "toMap(java.lang.Iterable<K> keys, com.google.common.base.Function<? super K, V> valueFunction)",
      "comment": "Returns an immutable map whose keys are the distinct elements of keys and whose value for each key was computed by valueFunction. The map's iteration order is the order of the first appearance of each key in keys. When there are multiple instances of a key in keys, it is unspecified whether valueFunction will be applied to more than one instance of that key and, if it is, which result will be mapped to that key in the returned map. If keys is a Set, a live view can be obtained instead of a copy using Maps#asMap(Set, Function).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toMap(java.util.Iterator<K> keys, com.google.common.base.Function<? super K, V> valueFunction)",
    "name": "toMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableMap<K, V>",
      "name": "com.google.common.collect.ImmutableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "keys"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "valueFunction"
      }
    ],
    "equivalence": {
      "member": "toMap(java.util.Iterator<K> keys, com.google.common.base.Function<? super K, V> valueFunction)",
      "comment": "Returns an immutable map whose keys are the distinct elements of keys and whose value for each key was computed by valueFunction. The map's iteration order is the order of the first appearance of each key in keys. When there are multiple instances of a key in keys, it is unspecified whether valueFunction will be applied to more than one instance of that key and, if it is, which result will be mapped to that key in the returned map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newConcurrentMap()",
    "name": "newConcurrentMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.ConcurrentMap<K, V>",
      "name": "java.util.concurrent.ConcurrentMap<K, V>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newConcurrentMap()",
      "comment": "Returns a general-purpose instance of ConcurrentMap, which supports all optional operations of the ConcurrentMap interface. It does not permit null keys or values. It is serializable. This is currently accomplished by calling MapMaker#makeMap(). It is preferable to use MapMaker directly (rather than through this method), as it presents numerous useful configuration options, such as the concurrency level, load factor, key/value reference types, and value computation.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "keyOrNull(java.util.Map$Entry<K, ?> entry)",
    "name": "keyOrNull",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "K",
      "name": "K",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map$Entry",
          "name": "Entry",
          "isArray": false
        },
        "name": "entry",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "keyOrNull(java.util.Map$Entry<K, ?> entry)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "safeContainsKey(java.util.Map<?, ?> map, java.lang.Object key)",
    "name": "safeContainsKey",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key"
      }
    ],
    "equivalence": {
      "member": "safeContainsKey(java.util.Map<?, ?> map, java.lang.Object key)",
      "comment": "Delegates to Map#containsKey. Returns false on ClassCastException and NullPointerException.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "immutableEntry(K key, V value)",
    "name": "immutableEntry",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Map$Entry<K, V>",
      "name": "java.util.Map$Entry<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key",
        "nullable": true
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "value",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "immutableEntry(K key, V value)",
      "comment": "Returns an immutable map entry with the specified key and value. The Entry#setValue operation throws an UnsupportedOperationException. The returned entry is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asEntryToEntryFunction(com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
    "name": "asEntryToEntryFunction",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.base.Function<java.util.Map$Entry<K, V1>, java.util.Map$Entry<K, V2>>",
      "name": "com.google.common.base.Function<java.util.Map$Entry<K, V1>, java.util.Map$Entry<K, V2>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      }
    ],
    "equivalence": {
      "member": "asEntryToEntryFunction(com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
      "comment": "Views an entry transformer as a function from entries to entries.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedHashMap(java.util.Map<? extends K, ? extends V> map)",
    "name": "newLinkedHashMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedHashMap<K, V>",
      "name": "java.util.LinkedHashMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "newLinkedHashMap(java.util.Map<? extends K, ? extends V> map)",
      "comment": "Creates a mutable, insertion-ordered LinkedHashMap instance with the same mappings as the specified map. Note: if mutability is not required, use ImmutableMap#copyOf(Map) instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transformEntriesIgnoreNavigable(java.util.SortedMap<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
    "name": "transformEntriesIgnoreNavigable",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V2>",
      "name": "java.util.SortedMap<K, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "fromMap"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.collect.Maps$EntryTransformer",
          "name": "EntryTransformer",
          "isArray": false
        },
        "name": "transformer"
      }
    ],
    "equivalence": {
      "member": "transformEntriesIgnoreNavigable(java.util.SortedMap<K, V1> fromMap, com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2> transformer)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "containsValueImpl(java.util.Map<?, ?> map, java.lang.Object value)",
    "name": "containsValueImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "value",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "containsValueImpl(java.util.Map<?, ?> map, java.lang.Object value)",
      "comment": "An implementation of Map#containsValue.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "synchronizedNavigableMap(java.util.NavigableMap<K, V> navigableMap)",
    "name": "synchronizedNavigableMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableMap<K, V>",
      "name": "java.util.NavigableMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableMap",
          "name": "NavigableMap",
          "isArray": false
        },
        "name": "navigableMap"
      }
    ],
    "equivalence": {
      "member": "synchronizedNavigableMap(java.util.NavigableMap<K, V> navigableMap)",
      "comment": "Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that all access to the backing navigable map is accomplished through the returned navigable map (or its views). It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its descendingMap, subMap, headMap or tailMap views.  NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>()); // Needn't be in synchronized block NavigableSet<K> set = map.navigableKeySet(); synchronized (map) { // Synchronizing on map, not set! Iterator<K> it = set.iterator(); // Must be in synchronized block while (it.hasNext()) { foo(it.next());  }} or:  NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>()); NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true); // Needn't be in synchronized block NavigableSet<K> set2 = map2.descendingKeySet(); synchronized (map) { // Synchronizing on map, not map2 or set2! Iterator<K> it = set2.iterator(); // Must be in synchronized block while (it.hasNext()) { foo(it.next());  }} Failure to follow this advice may result in non-deterministic behavior. The returned navigable map will be serializable if the specified navigable map is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "orNaturalOrder(java.util.Comparator<? super E> comparator)",
    "name": "orNaturalOrder",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Comparator<? super E>",
      "name": "java.util.Comparator<? super E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "comparator",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "orNaturalOrder(java.util.Comparator<? super E> comparator)",
      "comment": "Returns the specified comparator if not null; otherwise returns Ordering.natural(). This method is an abomination of generics; the only purpose of this method is to contain the ugly type-casting in one place.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asEntryTransformer(com.google.common.base.Function<? super V1, V2> function)",
    "name": "asEntryTransformer",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.Maps$EntryTransformer<K, V1, V2>",
      "name": "com.google.common.collect.Maps$EntryTransformer<K, V1, V2>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "asEntryTransformer(com.google.common.base.Function<? super V1, V2> function)",
      "comment": "Views a function as an entry transformer that ignores the entry key.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashMapWithExpectedSize(int expectedSize)",
    "name": "newHashMapWithExpectedSize",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.HashMap<K, V>",
      "name": "java.util.HashMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "expectedSize"
      }
    ],
    "equivalence": {
      "member": "newHashMapWithExpectedSize(int expectedSize)",
      "comment": "Creates a HashMap instance, with a high enough \"initial capacity\" that it should hold expectedSize elements without growth. This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method isn't inadvertently oversizing the returned map.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "containsKeyImpl(java.util.Map<?, ?> map, java.lang.Object key)",
    "name": "containsKeyImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "key",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "containsKeyImpl(java.util.Map<?, ?> map, java.lang.Object key)",
      "comment": "An admittedly inefficient implementation of Map#containsKey.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterSortedIgnoreNavigable(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
    "name": "filterSortedIgnoreNavigable",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedMap<K, V>",
      "name": "java.util.SortedMap<K, V>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedMap",
          "name": "SortedMap",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "entryPredicate"
      }
    ],
    "equivalence": {
      "member": "filterSortedIgnoreNavigable(java.util.SortedMap<K, V> unfiltered, com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>> entryPredicate)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asMapEntryIterator(java.util.Set<K> set, com.google.common.base.Function<? super K, V> function)",
    "name": "asMapEntryIterator",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Iterator<java.util.Map$Entry<K, V>>",
      "name": "java.util.Iterator<java.util.Map$Entry<K, V>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "asMapEntryIterator(java.util.Set<K> set, com.google.common.base.Function<? super K, V> function)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "putAllImpl(java.util.Map<K, V> self, java.util.Map<? extends K, ? extends V> map)",
    "name": "putAllImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "self"
      },
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "putAllImpl(java.util.Map<K, V> self, java.util.Map<? extends K, ? extends V> map)",
      "comment": "An implementation of Map#putAll.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newIdentityHashMap()",
    "name": "newIdentityHashMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Maps",
      "name": "Maps",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Maps",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.IdentityHashMap<K, V>",
      "name": "java.util.IdentityHashMap<K, V>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newIdentityHashMap()",
      "comment": "Creates an IdentityHashMap instance.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]