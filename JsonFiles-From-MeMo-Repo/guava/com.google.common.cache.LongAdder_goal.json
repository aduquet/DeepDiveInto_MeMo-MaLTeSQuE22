[
  {
    "signature": "fn(long v, long x)",
    "name": "fn",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "v"
      },
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "x"
      }
    ],
    "equivalence": {
      "comment": "Version of plus for use in retryUpdate.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "intValue()",
    "name": "intValue",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Returns the sum as an int after a narrowing primitive conversion.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sumThenReset()",
    "name": "sumThenReset",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Equivalent in effect to sum followed by reset. This method may apply for example during quiescent points between multithreaded computations. If there are updates concurrent with this method, the returned value is not guaranteed to be the final value occurring before the reset.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "sum()",
    "name": "sum",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Returns the current sum. The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the sum is being calculated might not be incorporated.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "add(long x)",
    "name": "add",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "long",
          "name": "long",
          "isArray": false
        },
        "name": "x"
      }
    ],
    "equivalence": {
      "comment": "Adds the given value.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "doubleValue()",
    "name": "doubleValue",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Returns the sum as a double after a widening primitive conversion.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "floatValue()",
    "name": "floatValue",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "float",
      "name": "float",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Returns the sum as a float after a widening primitive conversion.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "com.google.common.cache.LongAdder()",
    "name": "com.google.common.cache.LongAdder",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "parameters": [],
    "equivalence": {
      "comment": "Creates a new adder with initial sum of zero.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "decrement()",
    "name": "decrement",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Equivalent to add(-1).",
      "kind": "FreeText",
      "condition": "receiverObjectClone.add(-1); receiverObjectClone.equals(receiverObjectID)"
    }
  },
  {
    "signature": "toString()",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Returns the String representation of the sum.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "increment()",
    "name": "increment",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Equivalent to add(1).",
      "kind": "FreeText",
      "condition": " receiverObjectClone.add(1); receiverObjectClone.equals(receiverObjectID)"
    }
  },
  {
    "signature": "longValue()",
    "name": "longValue",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "long",
      "name": "long",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Equivalent to sum.",
      "kind": "FreeText",
      "condition": "methodResultID ==(receiverObjectClone.sum())"
    }
  },
  {
    "signature": "reset()",
    "name": "reset",
    "containingClass": {
      "qualifiedName": "com.google.common.cache.LongAdder",
      "name": "LongAdder",
      "isArray": false
    },
    "targetClass": "com.google.common.cache.LongAdder",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "comment": "Resets variables maintaining the sum to zero. This method may be a useful alternative to creating a new adder, but is only effective if there are no concurrent updates. Because this method is intrinsically racy, it should only be used when it is known that no threads are concurrently updating.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]