[
  {
    "signature": "java.awt.geom.AffineTransform()",
    "name": "java.awt.geom.AffineTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "parameters": [],
    "equivalence": {
      "member": "java.awt.geom.AffineTransform()",
      "comment": "Constructs a new AffineTransform representing the Identity transformation.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.awt.geom.AffineTransform(java.awt.geom.AffineTransform Tx)",
    "name": "java.awt.geom.AffineTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.geom.AffineTransform",
          "name": "AffineTransform",
          "isArray": false
        },
        "name": "Tx"
      }
    ],
    "equivalence": {
      "member": "java.awt.geom.AffineTransform(java.awt.geom.AffineTransform Tx)",
      "comment": "Constructs a new AffineTransform that is a copy of the specified AffineTransform object.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.awt.geom.AffineTransform(float m00, float m10, float m01, float m11, float m02, float m12)",
    "name": "java.awt.geom.AffineTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "m00"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "m10"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "m01"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "m11"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "m02"
      },
      {
        "type": {
          "qualifiedName": "float",
          "name": "float",
          "isArray": false
        },
        "name": "m12"
      }
    ],
    "equivalence": {
      "member": "java.awt.geom.AffineTransform(float m00, float m10, float m01, float m11, float m02, float m12)",
      "comment": "Constructs a new AffineTransform from 6 floating point values representing the 6 specifiable entries of the 3x3 transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.awt.geom.AffineTransform(float[] flatmatrix)",
    "name": "java.awt.geom.AffineTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "flatmatrix"
      }
    ],
    "equivalence": {
      "member": "java.awt.geom.AffineTransform(float[] flatmatrix)",
      "comment": "Constructs a new AffineTransform from an array of floating point values representing either the 4 non-translation entries or the 6 specifiable entries of the 3x3 transformation matrix. The values are retrieved from the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]}.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.awt.geom.AffineTransform(double m00, double m10, double m01, double m11, double m02, double m12)",
    "name": "java.awt.geom.AffineTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m00"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m10"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m01"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m11"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m02"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m12"
      }
    ],
    "equivalence": {
      "member": "java.awt.geom.AffineTransform(double m00, double m10, double m01, double m11, double m02, double m12)",
      "comment": "Constructs a new AffineTransform from 6 double precision values representing the 6 specifiable entries of the 3x3 transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "java.awt.geom.AffineTransform(double[] flatmatrix)",
    "name": "java.awt.geom.AffineTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "flatmatrix"
      }
    ],
    "equivalence": {
      "member": "java.awt.geom.AffineTransform(double[] flatmatrix)",
      "comment": "Constructs a new AffineTransform from an array of double precision values representing either the 4 non-translation entries or the 6 specifiable entries of the 3x3 transformation matrix. The values are retrieved from the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]}.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getTranslateInstance(double tx, double ty)",
    "name": "getTranslateInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "tx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "ty"
      }
    ],
    "equivalence": {
      "member": "getTranslateInstance(double tx, double ty)",
      "comment": "Returns a transform representing a translation transformation. The matrix representing the returned transform is:  [ 1 0 tx ] [ 0 1 ty ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRotateInstance(double theta)",
    "name": "getRotateInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "theta"
      }
    ],
    "equivalence": {
      "member": "getRotateInstance(double theta)",
      "comment": "Returns a transform representing a rotation transformation. The matrix representing the returned transform is:  [ cos(theta) -sin(theta) 0 ] [ sin(theta) cos(theta) 0 ] [ 0 0 1 ]  Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRotateInstance(double theta, double anchorx, double anchory)",
    "name": "getRotateInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "theta"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "getRotateInstance(double theta, double anchorx, double anchory)",
      "comment": "Returns a transform that rotates coordinates around an anchor point. This operation is equivalent to translating the coordinates so that the anchor point is at the origin (S1), then rotating them about the new origin (S2), and finally translating so that the intermediate origin is restored to the coordinates of the original anchor point (S3).  This operation is equivalent to the following sequence of calls:  AffineTransform Tx = new AffineTransform(); Tx.translate(anchorx, anchory); // S3: final translation Tx.rotate(theta); // S2: rotate around anchor Tx.translate(-anchorx, -anchory); // S1: translate anchor to origin  The matrix representing the returned transform is:  [ cos(theta) -sin(theta) x-x*cos+y*sin ] [ sin(theta) cos(theta) y-x*sin-y*cos ] [ 0 0 1 ]  Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRotateInstance(double vecx, double vecy)",
    "name": "getRotateInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecy"
      }
    ],
    "equivalence": {
      "member": "getRotateInstance(double vecx, double vecy)",
      "comment": "Returns a transform that rotates coordinates according to a rotation vector. All coordinates rotate about the origin by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, an identity transform is returned. This operation is equivalent to calling:  AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getRotateInstance(double vecx, double vecy, double anchorx, double anchory)",
    "name": "getRotateInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecy"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "getRotateInstance(double vecx, double vecy, double anchorx, double anchory)",
      "comment": "Returns a transform that rotates coordinates around an anchor point according to a rotation vector. All coordinates rotate about the specified anchor coordinates by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, an identity transform is returned. This operation is equivalent to calling:  AffineTransform.getRotateInstance(Math.atan2(vecy, vecx), anchorx, anchory);",
      "kind": "FreeText",
      "condition": "methodResultID.equals(java.awt.geom.AffineTransform.getRotateInstance(args[0],args[0]))"
    }
  },
  {
    "signature": "getQuadrantRotateInstance(int numquadrants)",
    "name": "getQuadrantRotateInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numquadrants"
      }
    ],
    "equivalence": {
      "member": "getQuadrantRotateInstance(int numquadrants)",
      "comment": "Returns a transform that rotates coordinates by the specified number of quadrants. This operation is equivalent to calling:  AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);  Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getQuadrantRotateInstance(int numquadrants, double anchorx, double anchory)",
    "name": "getQuadrantRotateInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numquadrants"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "getQuadrantRotateInstance(int numquadrants, double anchorx, double anchory)",
      "comment": "Returns a transform that rotates coordinates by the specified number of quadrants around the specified anchor point. This operation is equivalent to calling:  AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0, anchorx, anchory);  Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getScaleInstance(double sx, double sy)",
    "name": "getScaleInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "sx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "sy"
      }
    ],
    "equivalence": {
      "member": "getScaleInstance(double sx, double sy)",
      "comment": "Returns a transform representing a scaling transformation. The matrix representing the returned transform is:  [ sx 0 0 ] [ 0 sy 0 ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getShearInstance(double shx, double shy)",
    "name": "getShearInstance",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "shx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "shy"
      }
    ],
    "equivalence": {
      "member": "getShearInstance(double shx, double shy)",
      "comment": "Returns a transform representing a shearing transformation. The matrix representing the returned transform is:  [ 1 shx 0 ] [ shy 1 0 ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getType()",
    "name": "getType",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getType()",
      "comment": "Retrieves the flag bits describing the conversion properties of this transform. The return value is either one of the constants TYPE_IDENTITY or TYPE_GENERAL_TRANSFORM, or a combination of the appropriate flag bits. A valid combination of flag bits is an exclusive OR operation that can combine the TYPE_TRANSLATION flag bit in addition to either of the TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits as well as either of the TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getDeterminant()",
    "name": "getDeterminant",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getDeterminant()",
      "comment": "Returns the determinant of the matrix representation of the transform. The determinant is useful both to determine if the transform can be inverted and to get a single value representing the combined X and Y scaling of the transform.  If the determinant is non-zero, then this transform is invertible and the various methods that depend on the inverse transform do not need to throw a NoninvertibleTransformException. If the determinant is zero then this transform can not be inverted since the transform maps all input coordinates onto a line or a point. If the determinant is near enough to zero then inverse transform operations might not carry enough precision to produce meaningful results.  If this transform represents a uniform scale, as indicated by the getType method then the determinant also represents the square of the uniform scale factor by which all of the points are expanded from or contracted towards the origin. If this transform represents a non-uniform scale or more general transform then the determinant is not likely to represent a value useful for any purpose other than determining if inverse transforms are possible.  Mathematically, the determinant is calculated using the formula:  | m00 m01 m02 | | m10 m11 m12 | = m00 * m11 - m01 * m10 | 0 0 1 |",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "updateState()",
    "name": "updateState",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "updateState()",
      "comment": "Manually recalculates the state of the transform when the matrix changes too much to predict the effects on the state. The following table specifies what the various settings of the state field say about the values of the corresponding matrix element fields. Note that the rules governing the SCALE fields are slightly different depending on whether the SHEAR flag is also set.  SCALE SHEAR TRANSLATE m00/m11 m01/m10 m02/m12 IDENTITY 1.0 0.0 0.0 TRANSLATE (TR) 1.0 0.0 not both 0.0 SCALE (SC) not both 1.0 0.0 0.0 TR | SC not both 1.0 0.0 not both 0.0 SHEAR (SH) 0.0 not both 0.0 0.0 TR | SH 0.0 not both 0.0 not both 0.0 SC | SH not both 0.0 not both 0.0 0.0 TR | SC | SH not both 0.0 not both 0.0 not both 0.0",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getMatrix(double[] flatmatrix)",
    "name": "getMatrix",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "flatmatrix"
      }
    ],
    "equivalence": {
      "member": "getMatrix(double[] flatmatrix)",
      "comment": "Retrieves the 6 specifiable values in the 3x3 affine transformation matrix and places them into an array of double precisions values. The values are stored in the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}. An array of 4 doubles can also be specified, in which case only the first four elements representing the non-transform parts of the array are retrieved and the values are stored into the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getScaleX()",
    "name": "getScaleX",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getScaleX()",
      "comment": "Returns the X coordinate scaling element (m00) of the 3x3 affine transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getScaleY()",
    "name": "getScaleY",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getScaleY()",
      "comment": "Returns the Y coordinate scaling element (m11) of the 3x3 affine transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getShearX()",
    "name": "getShearX",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getShearX()",
      "comment": "Returns the X coordinate shearing element (m01) of the 3x3 affine transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getShearY()",
    "name": "getShearY",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getShearY()",
      "comment": "Returns the Y coordinate shearing element (m10) of the 3x3 affine transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getTranslateX()",
    "name": "getTranslateX",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getTranslateX()",
      "comment": "Returns the X coordinate of the translation element (m02) of the 3x3 affine transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "getTranslateY()",
    "name": "getTranslateY",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "double",
      "name": "double",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "getTranslateY()",
      "comment": "Returns the Y coordinate of the translation element (m12) of the 3x3 affine transformation matrix.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "translate(double tx, double ty)",
    "name": "translate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "tx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "ty"
      }
    ],
    "equivalence": {
      "member": "translate(double tx, double ty)",
      "comment": "Concatenates this transform with a translation transformation. This is equivalent to calling concatenate(T), where T is an AffineTransform represented by the following matrix:  [ 1 0 tx ] [ 0 1 ty ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "rotate(double theta)",
    "name": "rotate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "theta"
      }
    ],
    "equivalence": {
      "member": "rotate(double theta)",
      "comment": "Concatenates this transform with a rotation transformation. This is equivalent to calling concatenate(R), where R is an AffineTransform represented by the following matrix:  [ cos(theta) -sin(theta) 0 ] [ sin(theta) cos(theta) 0 ] [ 0 0 1 ]  Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "rotate(double theta, double anchorx, double anchory)",
    "name": "rotate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "theta"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "rotate(double theta, double anchorx, double anchory)",
      "comment": "Concatenates this transform with a transform that rotates coordinates around an anchor point. This operation is equivalent to translating the coordinates so that the anchor point is at the origin (S1), then rotating them about the new origin (S2), and finally translating so that the intermediate origin is restored to the coordinates of the original anchor point (S3).  This operation is equivalent to the following sequence of calls:  translate(anchorx, anchory); // S3: final translation rotate(theta); // S2: rotate around anchor translate(-anchorx, -anchory); // S1: translate anchor to origin  Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "rotate(double vecx, double vecy)",
    "name": "rotate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecy"
      }
    ],
    "equivalence": {
      "member": "rotate(double vecx, double vecy)",
      "comment": "Concatenates this transform with a transform that rotates coordinates according to a rotation vector. All coordinates rotate about the origin by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, no additional rotation is added to this transform. This operation is equivalent to calling:  rotate(Math.atan2(vecy, vecx));",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "rotate(double vecx, double vecy, double anchorx, double anchory)",
    "name": "rotate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecy"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "rotate(double vecx, double vecy, double anchorx, double anchory)",
      "comment": "Concatenates this transform with a transform that rotates coordinates around an anchor point according to a rotation vector. All coordinates rotate about the specified anchor coordinates by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, the transform is not modified in any way. This method is equivalent to calling:  rotate(Math.atan2(vecy, vecx), anchorx, anchory);",
      "kind": "FreeText",
      "condition": "receiverObjectClone.rotate(args[0],args[0]);\nreceiverObjectClone.equals(receiverObjectID)"
    }
  },
  {
    "signature": "quadrantRotate(int numquadrants)",
    "name": "quadrantRotate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numquadrants"
      }
    ],
    "equivalence": {
      "member": "quadrantRotate(int numquadrants)",
      "comment": "Concatenates this transform with a transform that rotates coordinates by the specified number of quadrants. This is equivalent to calling:  rotate(numquadrants * Math.PI / 2.0);  Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "quadrantRotate(int numquadrants, double anchorx, double anchory)",
    "name": "quadrantRotate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numquadrants"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "quadrantRotate(int numquadrants, double anchorx, double anchory)",
      "comment": "Concatenates this transform with a transform that rotates coordinates by the specified number of quadrants around the specified anchor point. This method is equivalent to calling:  rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);  Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "scale(double sx, double sy)",
    "name": "scale",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "sx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "sy"
      }
    ],
    "equivalence": {
      "member": "scale(double sx, double sy)",
      "comment": "Concatenates this transform with a scaling transformation. This is equivalent to calling concatenate(S), where S is an AffineTransform represented by the following matrix:  [ sx 0 0 ] [ 0 sy 0 ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "shear(double shx, double shy)",
    "name": "shear",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "shx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "shy"
      }
    ],
    "equivalence": {
      "member": "shear(double shx, double shy)",
      "comment": "Concatenates this transform with a shearing transformation. This is equivalent to calling concatenate(SH), where SH is an AffineTransform represented by the following matrix:  [ 1 shx 0 ] [ shy 1 0 ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToIdentity()",
    "name": "setToIdentity",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "setToIdentity()",
      "comment": "Resets this transform to the Identity transform.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToTranslation(double tx, double ty)",
    "name": "setToTranslation",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "tx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "ty"
      }
    ],
    "equivalence": {
      "member": "setToTranslation(double tx, double ty)",
      "comment": "Sets this transform to a translation transformation. The matrix representing this transform becomes:  [ 1 0 tx ] [ 0 1 ty ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToRotation(double theta)",
    "name": "setToRotation",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "theta"
      }
    ],
    "equivalence": {
      "member": "setToRotation(double theta)",
      "comment": "Sets this transform to a rotation transformation. The matrix representing this transform becomes:  [ cos(theta) -sin(theta) 0 ] [ sin(theta) cos(theta) 0 ] [ 0 0 1 ]  Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToRotation(double theta, double anchorx, double anchory)",
    "name": "setToRotation",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "theta"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "setToRotation(double theta, double anchorx, double anchory)",
      "comment": "Sets this transform to a translated rotation transformation. This operation is equivalent to translating the coordinates so that the anchor point is at the origin (S1), then rotating them about the new origin (S2), and finally translating so that the intermediate origin is restored to the coordinates of the original anchor point (S3).  This operation is equivalent to the following sequence of calls:  setToTranslation(anchorx, anchory); // S3: final translation rotate(theta); // S2: rotate around anchor translate(-anchorx, -anchory); // S1: translate anchor to origin  The matrix representing this transform becomes:  [ cos(theta) -sin(theta) x-x*cos+y*sin ] [ sin(theta) cos(theta) y-x*sin-y*cos ] [ 0 0 1 ]  Rotating by a positive angle theta rotates points on the positive X axis toward the positive Y axis. Note also the discussion of Handling 90-Degree Rotations above.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToRotation(double vecx, double vecy)",
    "name": "setToRotation",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecy"
      }
    ],
    "equivalence": {
      "member": "setToRotation(double vecx, double vecy)",
      "comment": "Sets this transform to a rotation transformation that rotates coordinates according to a rotation vector. All coordinates rotate about the origin by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, the transform is set to an identity transform. This operation is equivalent to calling:  setToRotation(Math.atan2(vecy, vecx));",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToRotation(double vecx, double vecy, double anchorx, double anchory)",
    "name": "setToRotation",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "vecy"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "setToRotation(double vecx, double vecy, double anchorx, double anchory)",
      "comment": "Sets this transform to a rotation transformation that rotates coordinates around an anchor point according to a rotation vector. All coordinates rotate about the specified anchor coordinates by the same amount. The amount of rotation is such that coordinates along the former positive X axis will subsequently align with the vector pointing from the origin to the specified vector coordinates. If both vecx and vecy are 0.0, the transform is set to an identity transform. This operation is equivalent to calling:  setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);",
      "kind": "FreeText",
      "condition": "receiverObjectClone.setToTranslation(args[0],args[0]);\nreceiverObjectClone.equals(receiverObjectID)"
    }
  },
  {
    "signature": "setToQuadrantRotation(int numquadrants)",
    "name": "setToQuadrantRotation",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numquadrants"
      }
    ],
    "equivalence": {
      "member": "setToQuadrantRotation(int numquadrants)",
      "comment": "Sets this transform to a rotation transformation that rotates coordinates by the specified number of quadrants. This operation is equivalent to calling:  setToRotation(numquadrants * Math.PI / 2.0);  Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToQuadrantRotation(int numquadrants, double anchorx, double anchory)",
    "name": "setToQuadrantRotation",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numquadrants"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchorx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "anchory"
      }
    ],
    "equivalence": {
      "member": "setToQuadrantRotation(int numquadrants, double anchorx, double anchory)",
      "comment": "Sets this transform to a translated rotation transformation that rotates coordinates by the specified number of quadrants around the specified anchor point. This operation is equivalent to calling:  setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);  Rotating by a positive number of quadrants rotates points on the positive X axis toward the positive Y axis.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToScale(double sx, double sy)",
    "name": "setToScale",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "sx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "sy"
      }
    ],
    "equivalence": {
      "member": "setToScale(double sx, double sy)",
      "comment": "Sets this transform to a scaling transformation. The matrix representing this transform becomes:  [ sx 0 0 ] [ 0 sy 0 ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setToShear(double shx, double shy)",
    "name": "setToShear",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "shx"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "shy"
      }
    ],
    "equivalence": {
      "member": "setToShear(double shx, double shy)",
      "comment": "Sets this transform to a shearing transformation. The matrix representing this transform becomes:  [ 1 shx 0 ] [ shy 1 0 ] [ 0 0 1 ]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setTransform(java.awt.geom.AffineTransform Tx)",
    "name": "setTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.geom.AffineTransform",
          "name": "AffineTransform",
          "isArray": false
        },
        "name": "Tx"
      }
    ],
    "equivalence": {
      "member": "setTransform(java.awt.geom.AffineTransform Tx)",
      "comment": "Sets this transform to a copy of the transform in the specified AffineTransform object.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "setTransform(double m00, double m10, double m01, double m11, double m02, double m12)",
    "name": "setTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m00"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m10"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m01"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m11"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m02"
      },
      {
        "type": {
          "qualifiedName": "double",
          "name": "double",
          "isArray": false
        },
        "name": "m12"
      }
    ],
    "equivalence": {
      "member": "setTransform(double m00, double m10, double m01, double m11, double m02, double m12)",
      "comment": "Sets this transform to the matrix specified by the 6 double precision values.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "concatenate(java.awt.geom.AffineTransform Tx)",
    "name": "concatenate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.geom.AffineTransform",
          "name": "AffineTransform",
          "isArray": false
        },
        "name": "Tx"
      }
    ],
    "equivalence": {
      "member": "concatenate(java.awt.geom.AffineTransform Tx)",
      "comment": "Concatenates an AffineTransform Tx to this AffineTransform Cx in the most commonly useful way to provide a new user space that is mapped to the former user space by Tx. Cx is updated to perform the combined transformation. Transforming a point p by the updated transform Cx' is equivalent to first transforming p by Tx and then transforming the result by the original transform Cx like this: Cx'(p) = Cx(Tx(p)) In matrix notation, if this transform Cx is represented by the matrix [this] and Tx is represented by the matrix [Tx] then this method does the following:  [this] = [this] x [Tx]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "preConcatenate(java.awt.geom.AffineTransform Tx)",
    "name": "preConcatenate",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.geom.AffineTransform",
          "name": "AffineTransform",
          "isArray": false
        },
        "name": "Tx"
      }
    ],
    "equivalence": {
      "member": "preConcatenate(java.awt.geom.AffineTransform Tx)",
      "comment": "Concatenates an AffineTransform Tx to this AffineTransform Cx in a less commonly used way such that Tx modifies the coordinate transformation relative to the absolute pixel space rather than relative to the existing user space. Cx is updated to perform the combined transformation. Transforming a point p by the updated transform Cx' is equivalent to first transforming p by the original transform Cx and then transforming the result by Tx like this: Cx'(p) = Tx(Cx(p)) In matrix notation, if this transform Cx is represented by the matrix [this] and Tx is represented by the matrix [Tx] then this method does the following:  [this] = [Tx] x [this]",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "createInverse()",
    "name": "createInverse",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "java.awt.geom.AffineTransform",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "createInverse()",
      "comment": "Returns an AffineTransform object representing the inverse transformation. The inverse transform Tx' of this transform Tx maps coordinates transformed by Tx back to their original coordinates. In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).  If this transform maps all coordinates onto a point or a line then it will not have an inverse, since coordinates that do not lie on the destination point or line will not have an inverse mapping. The getDeterminant method can be used to determine if this transform has no inverse, in which case an exception will be thrown if the createInverse method is called.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "invert()",
    "name": "invert",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "invert()",
      "comment": "Sets this transform to the inverse of itself. The inverse transform Tx' of this transform Tx maps coordinates transformed by Tx back to their original coordinates. In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).  If this transform maps all coordinates onto a point or a line then it will not have an inverse, since coordinates that do not lie on the destination point or line will not have an inverse mapping. The getDeterminant method can be used to determine if this transform has no inverse, in which case an exception will be thrown if the invert method is called. @see #getDeterminant @exception NoninvertibleTransformException if the matrix cannot be inverted.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transform(java.awt.geom.Point2D ptSrc, java.awt.geom.Point2D ptDst)",
    "name": "transform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.Point2D",
      "name": "java.awt.geom.Point2D",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.geom.Point2D",
          "name": "Point2D",
          "isArray": false
        },
        "name": "ptSrc"
      },
      {
        "type": {
          "qualifiedName": "java.awt.geom.Point2D",
          "name": "Point2D",
          "isArray": false
        },
        "name": "ptDst"
      }
    ],
    "equivalence": {
      "member": "transform(java.awt.geom.Point2D ptSrc, java.awt.geom.Point2D ptDst)",
      "comment": "Transforms the specified ptSrc and stores the result in ptDst. If ptDst is null, a new Point2D object is allocated and then the result of the transformation is stored in this object. In either case, ptDst, which contains the transformed point, is returned for convenience. If ptSrc and ptDst are the same object, the input point is correctly overwritten with the transformed point.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transform(java.awt.geom.Point2D[] ptSrc, int srcOff, java.awt.geom.Point2D[] ptDst, int dstOff, int numPts)",
    "name": "transform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.awt.geom.Point2D;",
          "name": "Point2D[]",
          "isArray": true
        },
        "name": "ptSrc"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "srcOff"
      },
      {
        "type": {
          "qualifiedName": "[Ljava.awt.geom.Point2D;",
          "name": "Point2D[]",
          "isArray": true
        },
        "name": "ptDst"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "dstOff"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numPts"
      }
    ],
    "equivalence": {
      "member": "transform(java.awt.geom.Point2D[] ptSrc, int srcOff, java.awt.geom.Point2D[] ptDst, int dstOff, int numPts)",
      "comment": "Transforms an array of point objects by this transform. If any element of the ptDst array is null, a new Point2D object is allocated and stored into that element before storing the results of the transformation.  Note that this method does not take any precautions to avoid problems caused by storing results into Point2D objects that will be used as the source for calculations further down the source array. This method does guarantee that if a specified Point2D object is both the source and destination for the same single point transform operation then the results will not be stored until the calculations are complete to avoid storing the results on top of the operands. If, however, the destination Point2D object for one operation is the same object as the source Point2D object for another operation further down the source array then the original coordinates in that point are overwritten before they can be converted.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transform(float[] srcPts, int srcOff, float[] dstPts, int dstOff, int numPts)",
    "name": "transform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "srcPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "srcOff"
      },
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "dstPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "dstOff"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numPts"
      }
    ],
    "equivalence": {
      "member": "transform(float[] srcPts, int srcOff, float[] dstPts, int dstOff, int numPts)",
      "comment": "Transforms an array of floating point coordinates by this transform. The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
    "name": "transform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "srcPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "srcOff"
      },
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "dstPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "dstOff"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numPts"
      }
    ],
    "equivalence": {
      "member": "transform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
      "comment": "Transforms an array of double precision coordinates by this transform. The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the indicated offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transform(float[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
    "name": "transform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "srcPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "srcOff"
      },
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "dstPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "dstOff"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numPts"
      }
    ],
    "equivalence": {
      "member": "transform(float[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
      "comment": "Transforms an array of floating point coordinates by this transform and stores the results into an array of doubles. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transform(double[] srcPts, int srcOff, float[] dstPts, int dstOff, int numPts)",
    "name": "transform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "srcPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "srcOff"
      },
      {
        "type": {
          "qualifiedName": "[F",
          "name": "float[]",
          "isArray": true
        },
        "name": "dstPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "dstOff"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numPts"
      }
    ],
    "equivalence": {
      "member": "transform(double[] srcPts, int srcOff, float[] dstPts, int dstOff, int numPts)",
      "comment": "Transforms an array of double precision coordinates by this transform and stores the results into an array of floats. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "inverseTransform(java.awt.geom.Point2D ptSrc, java.awt.geom.Point2D ptDst)",
    "name": "inverseTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.Point2D",
      "name": "java.awt.geom.Point2D",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.geom.Point2D",
          "name": "Point2D",
          "isArray": false
        },
        "name": "ptSrc"
      },
      {
        "type": {
          "qualifiedName": "java.awt.geom.Point2D",
          "name": "Point2D",
          "isArray": false
        },
        "name": "ptDst"
      }
    ],
    "equivalence": {
      "member": "inverseTransform(java.awt.geom.Point2D ptSrc, java.awt.geom.Point2D ptDst)",
      "comment": "Inverse transforms the specified ptSrc and stores the result in ptDst. If ptDst is null, a new Point2D object is allocated and then the result of the transform is stored in this object. In either case, ptDst, which contains the transformed point, is returned for convenience. If ptSrc and ptDst are the same object, the input point is correctly overwritten with the transformed point.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "inverseTransform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
    "name": "inverseTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "srcPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "srcOff"
      },
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "dstPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "dstOff"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numPts"
      }
    ],
    "equivalence": {
      "member": "inverseTransform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
      "comment": "Inverse transforms an array of double precision coordinates by this transform. The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the specified offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deltaTransform(java.awt.geom.Point2D ptSrc, java.awt.geom.Point2D ptDst)",
    "name": "deltaTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.geom.Point2D",
      "name": "java.awt.geom.Point2D",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.geom.Point2D",
          "name": "Point2D",
          "isArray": false
        },
        "name": "ptSrc"
      },
      {
        "type": {
          "qualifiedName": "java.awt.geom.Point2D",
          "name": "Point2D",
          "isArray": false
        },
        "name": "ptDst"
      }
    ],
    "equivalence": {
      "member": "deltaTransform(java.awt.geom.Point2D ptSrc, java.awt.geom.Point2D ptDst)",
      "comment": "Transforms the relative distance vector specified by ptSrc and stores the result in ptDst. A relative distance vector is transformed without applying the translation components of the affine transformation matrix using the following equations:  [ x' ] [ m00 m01 (m02) ] [ x ] [ m00x + m01y ] [ y' ] = [ m10 m11 (m12) ] [ y ] = [ m10x + m11y ] [ (1) ] [ (0) (0) ( 1 ) ] [ (1) ] [ (1) ]  If ptDst is null, a new Point2D object is allocated and then the result of the transform is stored in this object. In either case, ptDst, which contains the transformed point, is returned for convenience. If ptSrc and ptDst are the same object, the input point is correctly overwritten with the transformed point.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "deltaTransform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
    "name": "deltaTransform",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "void",
      "name": "void",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "srcPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "srcOff"
      },
      {
        "type": {
          "qualifiedName": "[D",
          "name": "double[]",
          "isArray": true
        },
        "name": "dstPts"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "dstOff"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "numPts"
      }
    ],
    "equivalence": {
      "member": "deltaTransform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts)",
      "comment": "Transforms an array of relative distance vectors by this transform. A relative distance vector is transformed without applying the translation components of the affine transformation matrix using the following equations:  [ x' ] [ m00 m01 (m02) ] [ x ] [ m00x + m01y ] [ y' ] = [ m10 m11 (m12) ] [ y ] = [ m10x + m11y ] [ (1) ] [ (0) (0) ( 1 ) ] [ (1) ] [ (1) ]  The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the indicated offset in the order [x0, y0, x1, y1, ..., xn, yn].",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "createTransformedShape(java.awt.Shape pSrc)",
    "name": "createTransformedShape",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.awt.Shape",
      "name": "java.awt.Shape",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.awt.Shape",
          "name": "Shape",
          "isArray": false
        },
        "name": "pSrc"
      }
    ],
    "equivalence": {
      "member": "createTransformedShape(java.awt.Shape pSrc)",
      "comment": "Returns a new Shape object defined by the geometry of the specified Shape after it has been transformed by this transform.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "toString()",
    "name": "toString",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.String",
      "name": "java.lang.String",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "toString()",
      "comment": "Returns a String that represents the value of this Object.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "isIdentity()",
    "name": "isIdentity",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "isIdentity()",
      "comment": "Returns true if this AffineTransform is an identity transform.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "clone()",
    "name": "clone",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.lang.Object",
      "name": "java.lang.Object",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "clone()",
      "comment": "Returns a copy of this AffineTransform object.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCode()",
    "name": "hashCode",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "hashCode()",
      "comment": "Returns the hashcode for this transform.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equals(java.lang.Object obj)",
    "name": "equals",
    "containingClass": {
      "qualifiedName": "java.awt.geom.AffineTransform",
      "name": "AffineTransform",
      "isArray": false
    },
    "targetClass": "java.awt.geom.AffineTransform",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "obj"
      }
    ],
    "equivalence": {
      "member": "equals(java.lang.Object obj)",
      "comment": "Returns true if this AffineTransform represents the same affine coordinate transform as the specified argument.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]