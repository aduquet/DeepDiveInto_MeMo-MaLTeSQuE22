[
  {
    "signature": "union(java.util.Set<? extends E> set1, java.util.Set<? extends E> set2)",
    "name": "union",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.Sets$SetView<E>",
      "name": "com.google.common.collect.Sets$SetView<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set1"
      },
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set2"
      }
    ],
    "equivalence": {
      "member": "union(java.util.Set<? extends E> set1, java.util.Set<? extends E> set2)",
      "comment": "Returns an unmodifiable view of the union of two sets. The returned set contains all elements that are contained in either backing set. Iterating over the returned set iterates first over all the elements of set1, then over each element of set2, in order, that is not contained in set1. Results are undefined if set1 and set2 are sets based on different equivalence relations (as HashSet, TreeSet, and the Map#keySet of an IdentityHashMap all are). Note: The returned view performs better when set1 is the smaller of the two sets. If you have reason to believe one of your sets will generally be smaller than the other, pass it first. Further, note that the current implementation is not suitable for nested union views, i.e. the following should be avoided when in a loop: union = Sets.union(union, anotherSet);, since iterating over the resulting set has a cubic complexity to the depth of the nesting.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedHashSet()",
    "name": "newLinkedHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedHashSet<E>",
      "name": "java.util.LinkedHashSet<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newLinkedHashSet()",
      "comment": "Creates a mutable, empty LinkedHashSet instance. Note: if mutability is not required, use ImmutableSet#of() instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "synchronizedNavigableSet(java.util.NavigableSet<E> navigableSet)",
    "name": "synchronizedNavigableSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableSet<E>",
      "name": "java.util.NavigableSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableSet",
          "name": "NavigableSet",
          "isArray": false
        },
        "name": "navigableSet"
      }
    ],
    "equivalence": {
      "member": "synchronizedNavigableSet(java.util.NavigableSet<E> navigableSet)",
      "comment": "Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that all access to the backing navigable set is accomplished through the returned navigable set (or its views). It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its descendingSet, subSet, headSet, or tailSet views.  NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>()); ... synchronized (set) { // Must be in the synchronized block Iterator<E> it = set.iterator(); while (it.hasNext()) { foo(it.next());  }} or:  NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>()); NavigableSet<E> set2 = set.descendingSet().headSet(foo); ... synchronized (set) { // Note: set, not set2!!! // Must be in the synchronized block Iterator<E> it = set2.descendingIterator(); while (it.hasNext()) foo(it.next());  }} Failure to follow this advice may result in non-deterministic behavior. The returned navigable set will be serializable if the specified navigable set is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "intersection(java.util.Set<E> set1, java.util.Set<?> set2)",
    "name": "intersection",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.Sets$SetView<E>",
      "name": "com.google.common.collect.Sets$SetView<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set1"
      },
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set2"
      }
    ],
    "equivalence": {
      "member": "intersection(java.util.Set<E> set1, java.util.Set<?> set2)",
      "comment": "Returns an unmodifiable view of the intersection of two sets. The returned set contains all elements that are contained by both backing sets. The iteration order of the returned set matches that of set1. Results are undefined if set1 and set2 are sets based on different equivalence relations (as HashSet, TreeSet, and the keySet of an IdentityHashMap all are). Note: The returned view performs slightly better when set1 is the smaller of the two sets. If you have reason to believe one of your sets will generally be smaller than the other, pass it first. Unfortunately, since this method sets the generic type of the returned set based on the type of the first set passed, this could in rare cases force you to make a cast, for example:  Set<Object> aFewBadObjects = ... Set<String> manyBadStrings = ... // impossible for a non-String to be in the intersection SuppressWarnings(\"unchecked\") Set<String> badStrings = (Set) Sets.intersection( aFewBadObjects, manyBadStrings); This is unfortunate, but should come up only very rarely.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newSetFromMap(java.util.Map<E, java.lang.Boolean> map)",
    "name": "newSetFromMap",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<E>",
      "name": "java.util.Set<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Map",
          "name": "Map",
          "isArray": false
        },
        "name": "map"
      }
    ],
    "equivalence": {
      "member": "newSetFromMap(java.util.Map<E, java.lang.Boolean> map)",
      "comment": "Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as java.util.HashMap or java.util.TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> identityHashSet = Sets.newSetFromMap( new IdentityHashMap<Object, Boolean>()); The returned set is serializable if the backing map is.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newTreeSet()",
    "name": "newTreeSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.TreeSet<E>",
      "name": "java.util.TreeSet<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newTreeSet()",
      "comment": "Creates a mutable, empty TreeSet instance sorted by the natural sort ordering of its elements. Note: if mutability is not required, use ImmutableSortedSet#of() instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedHashSetWithExpectedSize(int expectedSize)",
    "name": "newLinkedHashSetWithExpectedSize",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedHashSet<E>",
      "name": "java.util.LinkedHashSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "expectedSize"
      }
    ],
    "equivalence": {
      "member": "newLinkedHashSetWithExpectedSize(int expectedSize)",
      "comment": "Creates a LinkedHashSet instance, with a high enough \"initial capacity\" that it should hold expectedSize elements without growth. This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't inadvertently oversizing the returned set.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashSet()",
    "name": "newHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.HashSet<E>",
      "name": "java.util.HashSet<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newHashSet()",
      "comment": "Creates a mutable, initially empty HashSet instance. Note: if mutability is not required, use ImmutableSet#of() instead. If E is an Enum type, use EnumSet#noneOf instead. Otherwise, strongly consider using a LinkedHashSet instead, at the cost of increased memory footprint, to get deterministic iteration behavior. Note for Java 7 and later: this method is now unnecessary and should be treated as deprecated. Instead, use the HashSet constructor directly, taking advantage of the new \"diamond\" syntax.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newConcurrentHashSet(java.lang.Iterable<? extends E> elements)",
    "name": "newConcurrentHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<E>",
      "name": "java.util.Set<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newConcurrentHashSet(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a thread-safe set backed by a hash map and containing the given elements. The set is backed by a ConcurrentHashMap instance, and thus carries the same concurrency guarantees. Unlike HashSet, this class does NOT allow null to be used as an element. The set is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newTreeSet(java.lang.Iterable<? extends E> elements)",
    "name": "newTreeSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.TreeSet<E>",
      "name": "java.util.TreeSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newTreeSet(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a mutable TreeSet instance containing the given elements sorted by their natural ordering. Note: if mutability is not required, use ImmutableSortedSet#copyOf(Iterable) instead. Note: If elements is a SortedSet with an explicit comparator, this method has different behavior than TreeSet#TreeSet(SortedSet), which returns a TreeSet with that comparator.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedHashSet(java.lang.Iterable<? extends E> elements)",
    "name": "newLinkedHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedHashSet<E>",
      "name": "java.util.LinkedHashSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newLinkedHashSet(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a mutable LinkedHashSet instance containing the given elements in order. Note: if mutability is not required and the elements are non-null, use ImmutableSet#copyOf(Iterable) instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "powerSet(java.util.Set<E> set)",
    "name": "powerSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<java.util.Set<E>>",
      "name": "java.util.Set<java.util.Set<E>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set"
      }
    ],
    "equivalence": {
      "member": "powerSet(java.util.Set<E> set)",
      "comment": "Returns the set of all possible subsets of set. For example, powerSet(ImmutableSet.of(1, 2)) returns the set {{, {1}, {2}, {1, 2}}}. Elements appear in these subsets in the same iteration order as they appeared in the input set. The order in which these subsets appear in the outer set is undefined. Note that the power set of the empty set is not the empty set, but a one-element set containing the empty set. The returned set and its constituent sets use equals to decide whether two elements are identical, even if the input set uses a different concept of equivalence. Performance notes: while the power set of a set with size n is of size 2^n, its memory usage is only O(n). When the power set is constructed, the input set is merely copied. Only as the power set is iterated are the individual subsets created, and these subsets themselves occupy only a small constant amount of memory.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "removeAllImpl(java.util.Set<?> set, java.util.Iterator<?> iterator)",
    "name": "removeAllImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set"
      },
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "iterator"
      }
    ],
    "equivalence": {
      "member": "removeAllImpl(java.util.Set<?> set, java.util.Iterator<?> iterator)",
      "comment": "Remove each element in an iterable from a set.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashSet(E... elements)",
    "name": "newHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "java.util.HashSet<E>",
      "name": "java.util.HashSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newHashSet(E... elements)",
      "comment": "Creates a mutable HashSet instance initially containing the given elements. Note: if elements are non-null and won't be added or removed after this point, use ImmutableSet#of() or ImmutableSet#copyOf(Object[]) instead. If E is an Enum type, use EnumSet#of(Enum, Enum[]) instead. Otherwise, strongly consider using a LinkedHashSet instead, at the cost of increased memory footprint, to get deterministic iteration behavior. This method is just a small convenience, either for newHashSet(}Arrays#asList asList{@code (...)), or for creating an empty set then calling Collections#addAll. This method is not actually very useful and will likely be deprecated in the future.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashSet(java.lang.Iterable<? extends E> elements)",
    "name": "newHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.HashSet<E>",
      "name": "java.util.HashSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newHashSet(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a mutable HashSet instance containing the given elements. A very thin convenience for creating an empty set then calling Collection#addAll or Iterables#addAll. Note: if mutability is not required and the elements are non-null, use ImmutableSet#copyOf(Iterable) instead. (Or, change elements to be a FluentIterable and call elements.toSet().) Note: if E is an Enum type, use #newEnumSet(Iterable, Class) instead. Note for Java 7 and later: if elements is a Collection, you don't need this method. Instead, use the HashSet constructor directly, taking advantage of the new \"diamond\" syntax. Overall, this method is not very useful and will likely be deprecated in the future.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashSet(java.util.Iterator<? extends E> elements)",
    "name": "newHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.HashSet<E>",
      "name": "java.util.HashSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newHashSet(java.util.Iterator<? extends E> elements)",
      "comment": "Creates a mutable HashSet instance containing the given elements. A very thin convenience for creating an empty set and then calling Iterators#addAll. Note: if mutability is not required and the elements are non-null, use ImmutableSet#copyOf(Iterator) instead. Note: if E is an Enum type, you should create an EnumSet instead. Overall, this method is not very useful and will likely be deprecated in the future.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filter(java.util.Set<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
    "name": "filter",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<E>",
      "name": "java.util.Set<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "predicate"
      }
    ],
    "equivalence": {
      "member": "filter(java.util.Set<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
      "comment": "Returns the elements of unfiltered that satisfy a predicate. The returned set is a live view of unfiltered; changes to one affect the other. The resulting set's iterator does not support remove(), but all other set methods are supported. When given an element that doesn't satisfy the predicate, the set's add() and addAll() methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered set, only elements that satisfy the filter will be removed from the underlying set. The returned set isn't threadsafe or serializable, even if unfiltered is. Many of the filtered set's methods, such as size(), iterate across every element in the underlying set and determine which elements satisfy the filter. When a live view is not needed, it may be faster to copy Iterables.filter(unfiltered, predicate) and use the copy. Warning: predicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals. (See Iterables#filter(Iterable, Class) for related functionality.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filter(java.util.SortedSet<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
    "name": "filter",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedSet<E>",
      "name": "java.util.SortedSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedSet",
          "name": "SortedSet",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "predicate"
      }
    ],
    "equivalence": {
      "member": "filter(java.util.SortedSet<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
      "comment": "Returns the elements of a SortedSet, unfiltered, that satisfy a predicate. The returned set is a live view of unfiltered; changes to one affect the other. The resulting set's iterator does not support remove(), but all other set methods are supported. When given an element that doesn't satisfy the predicate, the set's add() and addAll() methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered set, only elements that satisfy the filter will be removed from the underlying set. The returned set isn't threadsafe or serializable, even if unfiltered is. Many of the filtered set's methods, such as size(), iterate across every element in the underlying set and determine which elements satisfy the filter. When a live view is not needed, it may be faster to copy Iterables.filter(unfiltered, predicate) and use the copy. Warning: predicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals. (See Iterables#filter(Iterable, Class) for related functionality.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filterSortedIgnoreNavigable(java.util.SortedSet<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
    "name": "filterSortedIgnoreNavigable",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.SortedSet<E>",
      "name": "java.util.SortedSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.SortedSet",
          "name": "SortedSet",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "predicate"
      }
    ],
    "equivalence": {
      "member": "filterSortedIgnoreNavigable(java.util.SortedSet<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "filter(java.util.NavigableSet<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
    "name": "filter",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableSet<E>",
      "name": "java.util.NavigableSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableSet",
          "name": "NavigableSet",
          "isArray": false
        },
        "name": "unfiltered"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Predicate",
          "name": "Predicate",
          "isArray": false
        },
        "name": "predicate"
      }
    ],
    "equivalence": {
      "member": "filter(java.util.NavigableSet<E> unfiltered, com.google.common.base.Predicate<? super E> predicate)",
      "comment": "Returns the elements of a NavigableSet, unfiltered, that satisfy a predicate. The returned set is a live view of unfiltered; changes to one affect the other. The resulting set's iterator does not support remove(), but all other set methods are supported. When given an element that doesn't satisfy the predicate, the set's add() and addAll() methods throw an IllegalArgumentException. When methods such as removeAll() and clear() are called on the filtered set, only elements that satisfy the filter will be removed from the underlying set. The returned set isn't threadsafe or serializable, even if unfiltered is. Many of the filtered set's methods, such as size(), iterate across every element in the underlying set and determine which elements satisfy the filter. When a live view is not needed, it may be faster to copy Iterables.filter(unfiltered, predicate) and use the copy. Warning: predicate must be consistent with equals, as documented at Predicate#apply. Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals. (See Iterables#filter(Iterable, Class) for related functionality.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "immutableEnumSet(E anElement, E... otherElements)",
    "name": "immutableEnumSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableSet<E>",
      "name": "com.google.common.collect.ImmutableSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Enum",
          "name": "Enum",
          "isArray": false
        },
        "name": "anElement"
      },
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Enum;",
          "name": "Enum[]",
          "isArray": true
        },
        "name": "otherElements"
      }
    ],
    "equivalence": {
      "member": "immutableEnumSet(E anElement, E... otherElements)",
      "comment": "Returns an immutable set instance containing the given enum elements. Internally, the returned set will be backed by an EnumSet. The iteration order of the returned set follows the enum's iteration order, not the order in which the elements are provided to the method.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newIdentityHashSet()",
    "name": "newIdentityHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<E>",
      "name": "java.util.Set<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newIdentityHashSet()",
      "comment": "Creates an empty Set that uses identity to determine equality. It compares object references, instead of calling equals, to determine whether a provided object matches an element in the set. For example, contains returns false when passed an object that equals a set member, but isn't the same instance. This behavior is similar to the way IdentityHashMap handles key lookups.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "immutableEnumSet(java.lang.Iterable<E> elements)",
    "name": "immutableEnumSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableSet<E>",
      "name": "com.google.common.collect.ImmutableSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "immutableEnumSet(java.lang.Iterable<E> elements)",
      "comment": "Returns an immutable set instance containing the given enum elements. Internally, the returned set will be backed by an EnumSet. The iteration order of the returned set follows the enum's iteration order, not the order in which the elements appear in the given collection.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newCopyOnWriteArraySet()",
    "name": "newCopyOnWriteArraySet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.CopyOnWriteArraySet<E>",
      "name": "java.util.concurrent.CopyOnWriteArraySet<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newCopyOnWriteArraySet()",
      "comment": "Creates an empty CopyOnWriteArraySet instance. Note: if you need an immutable empty Set, use Collections#emptySet instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newCopyOnWriteArraySet(java.lang.Iterable<? extends E> elements)",
    "name": "newCopyOnWriteArraySet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.CopyOnWriteArraySet<E>",
      "name": "java.util.concurrent.CopyOnWriteArraySet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newCopyOnWriteArraySet(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a CopyOnWriteArraySet instance containing the given elements.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "symmetricDifference(java.util.Set<? extends E> set1, java.util.Set<? extends E> set2)",
    "name": "symmetricDifference",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.Sets$SetView<E>",
      "name": "com.google.common.collect.Sets$SetView<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set1"
      },
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set2"
      }
    ],
    "equivalence": {
      "member": "symmetricDifference(java.util.Set<? extends E> set1, java.util.Set<? extends E> set2)",
      "comment": "Returns an unmodifiable view of the symmetric difference of two sets. The returned set contains all elements that are contained in either set1 or set2 but not in both. The iteration order of the returned set is undefined. Results are undefined if set1 and set2 are sets based on different equivalence relations (as HashSet, TreeSet, and the keySet of an IdentityHashMap all are).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "removeAllImpl(java.util.Set<?> set, java.util.Collection<?> collection)",
    "name": "removeAllImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set"
      },
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "collection"
      }
    ],
    "equivalence": {
      "member": "removeAllImpl(java.util.Set<?> set, java.util.Collection<?> collection)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "complementOf(java.util.Collection<E> collection)",
    "name": "complementOf",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.EnumSet<E>",
      "name": "java.util.EnumSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "collection"
      }
    ],
    "equivalence": {
      "member": "complementOf(java.util.Collection<E> collection)",
      "comment": "Creates an EnumSet consisting of all enum values that are not in the specified collection. If the collection is an EnumSet, this method has the same behavior as EnumSet#complementOf. Otherwise, the specified collection must contain at least one element, in order to determine the element type. If the collection could be empty, use #complementOf(Collection, Class) instead of this method.",
      "kind": "FreeText",
      "condition": "if(args[0] instanceof EnumSet) {methodResultID.equals(java.util.EnumSet.complementOf(args[0]))}"
    }
  },
  {
    "signature": "cartesianProduct(java.util.List<? extends java.util.Set<? extends B>> sets)",
    "name": "cartesianProduct",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<java.util.List<B>>",
      "name": "java.util.Set<java.util.List<B>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "sets"
      }
    ],
    "equivalence": {
      "member": "cartesianProduct(java.util.List<? extends java.util.Set<? extends B>> sets)",
      "comment": "Returns every possible list that can be formed by choosing one element from each of the given sets in order; the \"n-ary Cartesian product\" of the sets. For example:  Sets.cartesianProduct(ImmutableList.of( ImmutableSet.of(1, 2), ImmutableSet.of(\"A\", \"B\", \"C\"))) returns a set containing six lists:  <li>ImmutableList.of(1, \"A\") <li>ImmutableList.of(1, \"B\") <li>ImmutableList.of(1, \"C\") <li>ImmutableList.of(2, \"A\") <li>ImmutableList.of(2, \"B\") <li>ImmutableList.of(2, \"C\")  The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian products that you would get from nesting for loops:  for (B b0 : sets.get(0)) { for (B b1 : sets.get(1)) { ... ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...); // operate on tuple  }} Note that if any input set is empty, the Cartesian product will also be empty. If no sets at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent). Performance notes: while the cartesian product of sets of size m, n, p is a set of size m x n x p, its actual memory consumption is much smaller. When the cartesian set is constructed, the input sets are merely copied. Only as the resulting set is iterated are the individual lists created, and these are not retained after iteration.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "cartesianProduct(java.util.Set<? extends B>... sets)",
    "name": "cartesianProduct",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "java.util.Set<java.util.List<B>>",
      "name": "java.util.Set<java.util.List<B>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.util.Set;",
          "name": "Set[]",
          "isArray": true
        },
        "name": "sets"
      }
    ],
    "equivalence": {
      "member": "cartesianProduct(java.util.Set<? extends B>... sets)",
      "comment": "Returns every possible list that can be formed by choosing one element from each of the given sets in order; the \"n-ary Cartesian product\" of the sets. For example:  Sets.cartesianProduct( ImmutableSet.of(1, 2), ImmutableSet.of(\"A\", \"B\", \"C\")) returns a set containing six lists:  <li>ImmutableList.of(1, \"A\") <li>ImmutableList.of(1, \"B\") <li>ImmutableList.of(1, \"C\") <li>ImmutableList.of(2, \"A\") <li>ImmutableList.of(2, \"B\") <li>ImmutableList.of(2, \"C\")  The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian products that you would get from nesting for loops:  for (B b0 : sets.get(0)) { for (B b1 : sets.get(1)) { ... ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...); // operate on tuple  }} Note that if any input set is empty, the Cartesian product will also be empty. If no sets at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent). Performance notes: while the cartesian product of sets of size m, n, p is a set of size m x n x p, its actual memory consumption is much smaller. When the cartesian set is constructed, the input sets are merely copied. Only as the resulting set is iterated are the individual lists created, and these are not retained after iteration.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "difference(java.util.Set<E> set1, java.util.Set<?> set2)",
    "name": "difference",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.Sets$SetView<E>",
      "name": "com.google.common.collect.Sets$SetView<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set1"
      },
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "set2"
      }
    ],
    "equivalence": {
      "member": "difference(java.util.Set<E> set1, java.util.Set<?> set2)",
      "comment": "Returns an unmodifiable view of the difference of two sets. The returned set contains all elements that are contained by set1 and not contained by set2. set2 may also contain elements not present in set1; these are simply ignored. The iteration order of the returned set matches that of set1. Results are undefined if set1 and set2 are sets based on different equivalence relations (as HashSet, TreeSet, and the keySet of an IdentityHashMap all are).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equalsImpl(java.util.Set<?> s, java.lang.Object object)",
    "name": "equalsImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "s"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "object",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "equalsImpl(java.util.Set<?> s, java.lang.Object object)",
      "comment": "An implementation for Set#equals(Object).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newTreeSet(java.util.Comparator<? super E> comparator)",
    "name": "newTreeSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.TreeSet<E>",
      "name": "java.util.TreeSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Comparator",
          "name": "Comparator",
          "isArray": false
        },
        "name": "comparator"
      }
    ],
    "equivalence": {
      "member": "newTreeSet(java.util.Comparator<? super E> comparator)",
      "comment": "Creates a mutable, empty TreeSet instance with the given comparator. Note: if mutability is not required, use ImmutableSortedSet.orderedBy(comparator).build() instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newEnumSet(java.lang.Iterable<E> iterable, java.lang.Class<E> elementType)",
    "name": "newEnumSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.EnumSet<E>",
      "name": "java.util.EnumSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "iterable"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Class",
          "name": "Class",
          "isArray": false
        },
        "name": "elementType"
      }
    ],
    "equivalence": {
      "member": "newEnumSet(java.lang.Iterable<E> iterable, java.lang.Class<E> elementType)",
      "comment": "Returns a new, mutable EnumSet instance containing the given elements in their natural order. This method behaves identically to EnumSet#copyOf(Collection), but also accepts non-Collection iterables and empty iterables.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newConcurrentHashSet()",
    "name": "newConcurrentHashSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.Set<E>",
      "name": "java.util.Set<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newConcurrentHashSet()",
      "comment": "Creates a thread-safe set backed by a hash map. The set is backed by a ConcurrentHashMap instance, and thus carries the same concurrency guarantees. Unlike HashSet, this class does NOT allow null to be used as an element. The set is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCodeImpl(java.util.Set<?> s)",
    "name": "hashCodeImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Set",
          "name": "Set",
          "isArray": false
        },
        "name": "s"
      }
    ],
    "equivalence": {
      "member": "hashCodeImpl(java.util.Set<?> s)",
      "comment": "An implementation for Set#hashCode().",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newHashSetWithExpectedSize(int expectedSize)",
    "name": "newHashSetWithExpectedSize",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.HashSet<E>",
      "name": "java.util.HashSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "expectedSize"
      }
    ],
    "equivalence": {
      "member": "newHashSetWithExpectedSize(int expectedSize)",
      "comment": "Creates a HashSet instance, with a high enough initial table size that it should hold expectedSize elements without resizing. This behavior cannot be broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method isn't inadvertently oversizing the returned set.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "complementOf(java.util.Collection<E> collection, java.lang.Class<E> type)",
    "name": "complementOf",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.EnumSet<E>",
      "name": "java.util.EnumSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Collection",
          "name": "Collection",
          "isArray": false
        },
        "name": "collection"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Class",
          "name": "Class",
          "isArray": false
        },
        "name": "type"
      }
    ],
    "equivalence": {
      "member": "complementOf(java.util.Collection<E> collection, java.lang.Class<E> type)",
      "comment": "Creates an EnumSet consisting of all enum values that are not in the specified collection. This is equivalent to EnumSet#complementOf, but can act on any input collection, as long as the elements are of enum type.",
      "kind": "FreeText",
      "condition": "if(args[0] instanceof EnumSet) {methodResultID.equals(java.util.EnumSet.complementOf(args[0]))}"
    }
  },
  {
    "signature": "unmodifiableNavigableSet(java.util.NavigableSet<E> set)",
    "name": "unmodifiableNavigableSet",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Sets",
      "name": "Sets",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Sets",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.NavigableSet<E>",
      "name": "java.util.NavigableSet<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.NavigableSet",
          "name": "NavigableSet",
          "isArray": false
        },
        "name": "set"
      }
    ],
    "equivalence": {
      "member": "unmodifiableNavigableSet(java.util.NavigableSet<E> set)",
      "comment": "Returns an unmodifiable view of the specified navigable set. This method allows modules to provide users with \"read-only\" access to internal navigable sets. Query operations on the returned set \"read through\" to the specified set, and attempts to modify the returned set, whether direct or via its collection views, result in an UnsupportedOperationException. The returned navigable set will be serializable if the specified navigable set is serializable.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]