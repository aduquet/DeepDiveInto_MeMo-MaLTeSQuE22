[
  {
    "signature": "newArrayList()",
    "name": "newArrayList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.ArrayList<E>",
      "name": "java.util.ArrayList<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newArrayList()",
      "comment": "Creates a mutable, empty ArrayList instance (for Java 6 and earlier). Note: if mutability is not required, use ImmutableList#of() instead. Note for Java 7 and later: this method is now unnecessary and should be treated as deprecated. Instead, use the ArrayList ArrayList#ArrayList() constructor directly, taking advantage of the new \"diamond\" syntax.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "charactersOf(java.lang.CharSequence sequence)",
    "name": "charactersOf",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<java.lang.Character>",
      "name": "java.util.List<java.lang.Character>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.CharSequence",
          "name": "CharSequence",
          "isArray": false
        },
        "name": "sequence"
      }
    ],
    "equivalence": {
      "member": "charactersOf(java.lang.CharSequence sequence)",
      "comment": "Returns a view of the specified CharSequence as a List<Character>, viewing sequence as a sequence of Unicode code units. The view does not support any modification operations, but reflects any changes to the underlying character sequence.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "indexOfImpl(java.util.List<?> list, java.lang.Object element)",
    "name": "indexOfImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "element",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "indexOfImpl(java.util.List<?> list, java.lang.Object element)",
      "comment": "An implementation of List#indexOf(Object).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newCopyOnWriteArrayList(java.lang.Iterable<? extends E> elements)",
    "name": "newCopyOnWriteArrayList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.CopyOnWriteArrayList<E>",
      "name": "java.util.concurrent.CopyOnWriteArrayList<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newCopyOnWriteArrayList(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a CopyOnWriteArrayList instance containing the given elements.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asList(E first, E second, E[] rest)",
    "name": "asList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<E>",
      "name": "java.util.List<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "first",
        "nullable": true
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "second",
        "nullable": true
      },
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "rest"
      }
    ],
    "equivalence": {
      "member": "asList(E first, E second, E[] rest)",
      "comment": "Returns an unmodifiable list containing the specified first and second element, and backed by the specified array of additional elements. Changes to the rest array will be reflected in the returned list. Unlike Arrays#asList, the returned list is unmodifiable. This is useful when a varargs method needs to use a signature such as (Foo firstFoo, Foo secondFoo, Foo... moreFoos), in order to avoid overload ambiguity or to enforce a minimum argument count. The returned list is serializable and implements RandomAccess.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newArrayList(E... elements)",
    "name": "newArrayList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "java.util.ArrayList<E>",
      "name": "java.util.ArrayList<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newArrayList(E... elements)",
      "comment": "Creates a mutable ArrayList instance containing the given elements. Note: essentially the only reason to use this method is when you will need to add or remove elements later. Otherwise, for non-null elements use ImmutableList#of() (for varargs) or ImmutableList#copyOf(Object[]) (for an array) instead. If any elements might be null, or you need support for List#set(int, Object), use Arrays#asList. Note that even when you do need the ability to add or remove, this method provides only a tiny bit of syntactic sugar for newArrayList(}Arrays#asList asList{@code (...)), or for creating an empty list then calling Collections#addAll. This method is not actually very useful and will likely be deprecated in the future.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newArrayList(java.lang.Iterable<? extends E> elements)",
    "name": "newArrayList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.ArrayList<E>",
      "name": "java.util.ArrayList<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newArrayList(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a mutable ArrayList instance containing the given elements; a very thin shortcut for creating an empty list then calling Iterables#addAll. Note: if mutability is not required and the elements are non-null, use ImmutableList#copyOf(Iterable) instead. (Or, change elements to be a FluentIterable and call elements.toList().) Note for Java 7 and later: if elements is a Collection, you don't need this method. Use the ArrayList ArrayList#ArrayList(Collection) constructor directly, taking advantage of the new \"diamond\" syntax.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newArrayList(java.util.Iterator<? extends E> elements)",
    "name": "newArrayList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.ArrayList<E>",
      "name": "java.util.ArrayList<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.Iterator",
          "name": "Iterator",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newArrayList(java.util.Iterator<? extends E> elements)",
      "comment": "Creates a mutable ArrayList instance containing the given elements; a very thin shortcut for creating an empty list and then calling Iterators#addAll. Note: if mutability is not required and the elements are non-null, use ImmutableList#copyOf(Iterator) instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "addAllImpl(java.util.List<E> list, int index, java.lang.Iterable<? extends E> elements)",
    "name": "addAllImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "addAllImpl(java.util.List<E> list, int index, java.lang.Iterable<? extends E> elements)",
      "comment": "An implementation of List#addAll(int, Collection).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "computeArrayListCapacity(int arraySize)",
    "name": "computeArrayListCapacity",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "arraySize"
      }
    ],
    "equivalence": {
      "member": "computeArrayListCapacity(int arraySize)",
      "comment": "",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedList(java.lang.Iterable<? extends E> elements)",
    "name": "newLinkedList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedList<E>",
      "name": "java.util.LinkedList<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "elements"
      }
    ],
    "equivalence": {
      "member": "newLinkedList(java.lang.Iterable<? extends E> elements)",
      "comment": "Creates a mutable LinkedList instance containing the given elements; a very thin shortcut for creating an empty list then calling Iterables#addAll. Note: if mutability is not required and the elements are non-null, use ImmutableList#copyOf(Iterable) instead. (Or, change elements to be a FluentIterable and call elements.toList().) Performance note: ArrayList and java.util.ArrayDeque consistently outperform LinkedList except in certain rare and specific situations. Unless you have spent a lot of time benchmarking your specific needs, use one of those instead. Note for Java 7 and later: if elements is a Collection, you don't need this method. Use the LinkedList LinkedList#LinkedList(Collection) constructor directly, taking advantage of the new \"diamond\" syntax.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "asList(E first, E[] rest)",
    "name": "asList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<E>",
      "name": "java.util.List<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "first",
        "nullable": true
      },
      {
        "type": {
          "qualifiedName": "[Ljava.lang.Object;",
          "name": "Object[]",
          "isArray": true
        },
        "name": "rest"
      }
    ],
    "equivalence": {
      "member": "asList(E first, E[] rest)",
      "comment": "Returns an unmodifiable list containing the specified first element and backed by the specified array of additional elements. Changes to the rest array will be reflected in the returned list. Unlike Arrays#asList, the returned list is unmodifiable. This is useful when a varargs method needs to use a signature such as (Foo firstFoo, Foo... moreFoos), in order to avoid overload ambiguity or to enforce a minimum argument count. The returned list is serializable and implements RandomAccess.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "charactersOf(java.lang.String string)",
    "name": "charactersOf",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "com.google.common.collect.ImmutableList<java.lang.Character>",
      "name": "com.google.common.collect.ImmutableList<java.lang.Character>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.String",
          "name": "String",
          "isArray": false
        },
        "name": "string"
      }
    ],
    "equivalence": {
      "member": "charactersOf(java.lang.String string)",
      "comment": "Returns a view of the specified string as an immutable list of Character values.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "lastIndexOfImpl(java.util.List<?> list, java.lang.Object element)",
    "name": "lastIndexOfImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "element",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "lastIndexOfImpl(java.util.List<?> list, java.lang.Object element)",
      "comment": "An implementation of List#lastIndexOf(Object).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newCopyOnWriteArrayList()",
    "name": "newCopyOnWriteArrayList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.concurrent.CopyOnWriteArrayList<E>",
      "name": "java.util.concurrent.CopyOnWriteArrayList<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newCopyOnWriteArrayList()",
      "comment": "Creates an empty CopyOnWriteArrayList instance. Note: if you need an immutable empty List, use Collections#emptyList instead.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "reverse(java.util.List<T> list)",
    "name": "reverse",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<T>",
      "name": "java.util.List<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      }
    ],
    "equivalence": {
      "member": "reverse(java.util.List<T> list)",
      "comment": "Returns a reversed view of the specified list. For example, Lists.reverse(Arrays.asList(1, 2, 3)) returns a list containing 3, 2, 1. The returned list is backed by this list, so changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. The returned list is random-access if the specified list is random access.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newLinkedList()",
    "name": "newLinkedList",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.LinkedList<E>",
      "name": "java.util.LinkedList<E>",
      "isArray": false
    },
    "parameters": [],
    "equivalence": {
      "member": "newLinkedList()",
      "comment": "Creates a mutable, empty LinkedList instance (for Java 6 and earlier). Note: if you won't be adding any elements to the list, use ImmutableList#of() instead. Performance note: ArrayList and java.util.ArrayDeque consistently outperform LinkedList except in certain rare and specific situations. Unless you have spent a lot of time benchmarking your specific needs, use one of those instead. Note for Java 7 and later: this method is now unnecessary and should be treated as deprecated. Instead, use the LinkedList LinkedList#LinkedList() constructor directly, taking advantage of the new \"diamond\" syntax.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "hashCodeImpl(java.util.List<?> list)",
    "name": "hashCodeImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "int",
      "name": "int",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      }
    ],
    "equivalence": {
      "member": "hashCodeImpl(java.util.List<?> list)",
      "comment": "An implementation of List#hashCode().",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "cast(java.lang.Iterable<T> iterable)",
    "name": "cast",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<T>",
      "name": "java.util.List<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.lang.Iterable",
          "name": "Iterable",
          "isArray": false
        },
        "name": "iterable"
      }
    ],
    "equivalence": {
      "member": "cast(java.lang.Iterable<T> iterable)",
      "comment": "Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "subListImpl(java.util.List<E> list, int fromIndex, int toIndex)",
    "name": "subListImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<E>",
      "name": "java.util.List<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "fromIndex"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "toIndex"
      }
    ],
    "equivalence": {
      "member": "subListImpl(java.util.List<E> list, int fromIndex, int toIndex)",
      "comment": "An implementation of List#subList(int, int).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newArrayListWithExpectedSize(int estimatedSize)",
    "name": "newArrayListWithExpectedSize",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.ArrayList<E>",
      "name": "java.util.ArrayList<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "estimatedSize"
      }
    ],
    "equivalence": {
      "member": "newArrayListWithExpectedSize(int estimatedSize)",
      "comment": "Creates an ArrayList instance to hold estimatedSize elements, plus an unspecified amount of padding; you almost certainly mean to call #newArrayListWithCapacity (see that method for further advice on usage). Note: This method will soon be deprecated. Even in the rare case that you do want some amount of padding, it's best if you choose your desired amount explicitly.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "partition(java.util.List<T> list, int size)",
    "name": "partition",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<java.util.List<T>>",
      "name": "java.util.List<java.util.List<T>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "size"
      }
    ],
    "equivalence": {
      "member": "partition(java.util.List<T> list, int size)",
      "comment": "Returns consecutive List#subList(int, int) sublists of a list, each of the same size (the final list may be smaller). For example, partitioning a list containing [a, b, c, d, e] with a partition size of 3 yields [[a, b, c], [d, e]] -- an outer list containing two inner lists of three and two elements, all in the original order. The outer list is unmodifiable, but reflects the latest state of the source list. The inner lists are sublist views of the original list, produced on demand using List#subList(int, int), and are subject to all the usual caveats about modification as explained in that API.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "listIteratorImpl(java.util.List<E> list, int index)",
    "name": "listIteratorImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.ListIterator<E>",
      "name": "java.util.ListIterator<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "list"
      },
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "index"
      }
    ],
    "equivalence": {
      "member": "listIteratorImpl(java.util.List<E> list, int index)",
      "comment": "Returns an implementation of List#listIterator(int).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "newArrayListWithCapacity(int initialArraySize)",
    "name": "newArrayListWithCapacity",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.ArrayList<E>",
      "name": "java.util.ArrayList<E>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "int",
          "name": "int",
          "isArray": false
        },
        "name": "initialArraySize"
      }
    ],
    "equivalence": {
      "member": "newArrayListWithCapacity(int initialArraySize)",
      "comment": "Creates an ArrayList instance backed by an array with the specified initial size; simply delegates to ArrayList#ArrayList(int). Note for Java 7 and later: this method is now unnecessary and should be treated as deprecated. Instead, use new }ArrayList#ArrayList(int) ArrayList{@code <>(int) directly, taking advantage of the new \"diamond\" syntax. (Unlike here, there is no risk of overload ambiguity, since the ArrayList constructors very wisely did not accept varargs.)",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "cartesianProduct(java.util.List<? extends java.util.List<? extends B>> lists)",
    "name": "cartesianProduct",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<java.util.List<B>>",
      "name": "java.util.List<java.util.List<B>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "lists"
      }
    ],
    "equivalence": {
      "member": "cartesianProduct(java.util.List<? extends java.util.List<? extends B>> lists)",
      "comment": "Returns every possible list that can be formed by choosing one element from each of the given lists in order; the \"n-ary Cartesian product\" of the lists. For example:  Lists.cartesianProduct(ImmutableList.of( ImmutableList.of(1, 2), ImmutableList.of(\"A\", \"B\", \"C\"))) returns a list containing six lists in the following order:  <li>ImmutableList.of(1, \"A\") <li>ImmutableList.of(1, \"B\") <li>ImmutableList.of(1, \"C\") <li>ImmutableList.of(2, \"A\") <li>ImmutableList.of(2, \"B\") <li>ImmutableList.of(2, \"C\")  The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian products that you would get from nesting for loops:  for (B b0 : lists.get(0)) { for (B b1 : lists.get(1)) { ... ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...); // operate on tuple  }} Note that if any input list is empty, the Cartesian product will also be empty. If no lists at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent). Performance notes: while the cartesian product of lists of size m, n, p is a list of size m x n x p, its actual memory consumption is much smaller. When the cartesian product is constructed, the input lists are merely copied. Only as the resulting list is iterated are the individual lists created, and these are not retained after iteration.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "cartesianProduct(java.util.List<? extends B>... lists)",
    "name": "cartesianProduct",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": true,
    "returnType": {
      "qualifiedName": "java.util.List<java.util.List<B>>",
      "name": "java.util.List<java.util.List<B>>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "[Ljava.util.List;",
          "name": "List[]",
          "isArray": true
        },
        "name": "lists"
      }
    ],
    "equivalence": {
      "member": "cartesianProduct(java.util.List<? extends B>... lists)",
      "comment": "Returns every possible list that can be formed by choosing one element from each of the given lists in order; the \"n-ary Cartesian product\" of the lists. For example:  Lists.cartesianProduct(ImmutableList.of( ImmutableList.of(1, 2), ImmutableList.of(\"A\", \"B\", \"C\"))) returns a list containing six lists in the following order:  <li>ImmutableList.of(1, \"A\") <li>ImmutableList.of(1, \"B\") <li>ImmutableList.of(1, \"C\") <li>ImmutableList.of(2, \"A\") <li>ImmutableList.of(2, \"B\") <li>ImmutableList.of(2, \"C\")  The result is guaranteed to be in the \"traditional\", lexicographical order for Cartesian products that you would get from nesting for loops:  for (B b0 : lists.get(0)) { for (B b1 : lists.get(1)) { ... ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...); // operate on tuple  }} Note that if any input list is empty, the Cartesian product will also be empty. If no lists at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent). Performance notes: while the cartesian product of lists of size m, n, p is a list of size m x n x p, its actual memory consumption is much smaller. When the cartesian product is constructed, the input lists are merely copied. Only as the resulting list is iterated are the individual lists created, and these are not retained after iteration.",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "equalsImpl(java.util.List<?> thisList, java.lang.Object other)",
    "name": "equalsImpl",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "boolean",
      "name": "boolean",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "thisList"
      },
      {
        "type": {
          "qualifiedName": "java.lang.Object",
          "name": "Object",
          "isArray": false
        },
        "name": "other",
        "nullable": true
      }
    ],
    "equivalence": {
      "member": "equalsImpl(java.util.List<?> thisList, java.lang.Object other)",
      "comment": "An implementation of List#equals(Object).",
      "kind": "FreeText",
      "condition": ""
    }
  },
  {
    "signature": "transform(java.util.List<F> fromList, com.google.common.base.Function<? super F, ? extends T> function)",
    "name": "transform",
    "containingClass": {
      "qualifiedName": "com.google.common.collect.Lists",
      "name": "Lists",
      "isArray": false
    },
    "targetClass": "com.google.common.collect.Lists",
    "isVarArgs": false,
    "returnType": {
      "qualifiedName": "java.util.List<T>",
      "name": "java.util.List<T>",
      "isArray": false
    },
    "parameters": [
      {
        "type": {
          "qualifiedName": "java.util.List",
          "name": "List",
          "isArray": false
        },
        "name": "fromList"
      },
      {
        "type": {
          "qualifiedName": "com.google.common.base.Function",
          "name": "Function",
          "isArray": false
        },
        "name": "function"
      }
    ],
    "equivalence": {
      "member": "transform(java.util.List<F> fromList, com.google.common.base.Function<? super F, ? extends T> function)",
      "comment": "Returns a list that applies function to each element of fromList. The returned list is a transformed view of fromList; changes to fromList will be reflected in the returned list and vice versa. Since functions are not reversible, the transform is one-way and new items cannot be stored in the returned list. The add, addAll and set methods are unsupported in the returned list. The function is applied lazily, invoked when needed. This is necessary for the returned list to be a view, but it means that the function will be applied many times for bulk operations like List#contains and List#hashCode. For this to perform well, function should be fast. To avoid lazy evaluation when the returned list doesn't need to be a view, copy the returned list into a new list of your choosing. If fromList implements RandomAccess, so will the returned list. The returned list is threadsafe if the supplied list and function are. If only a Collection or Iterable input is available, use Collections2#transform or Iterables#transform. Note: serializing the returned list is implemented by serializing fromList, its contents, and function -- not by serializing the transformed values. This can lead to surprising behavior, so serializing the returned list is not recommended. Instead, copy the list using ImmutableList#copyOf(Collection) (for example), then serialize the copy. Other methods similar to this do not implement serialization at all for this reason.",
      "kind": "FreeText",
      "condition": ""
    }
  }
]